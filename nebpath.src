C 10 Oct 19 - MH  - Release 2
C 20 Jul 19 - MH  - Start adding new features
C 11 Jul 19 - MH  - All bugs are fixed
C 25 Jun 19 - MH  - Bug fix and cleanup source code
C 17 Jun 19 - MH  - Improved restart system to restart easily
C 11 Jun 19 - MH  - Add Climbing Image option for TS searching.
C 04 Jun 19 - MH  - Add some optimizers
C 16 Apr 19 - SK  - Clean up for gfortran
C 15 Mar 19 - SK  - Start working on parallel computation
C 12 Mar 19 - SK  - Generate structures between the neighbouring images at the end of calculation
C 11 Mar 19 - SK  - Add a restart option.
C 09 Mar 19 - SK  - Finish coding.  Need to check options and test jobs.
C 07 Mar 19 - SK  - Got reasonable energies and gradients at each initial image
C 06 Mar 19 - SK  - Start adding NEB_run
C 05 Mar 19 - SK  - Debugging IDPP routines
C 04 Mar 19 - SK  - Start adding Sawada's routines
C 23 Feb 19 - SK  - Start creating NEBpath routines
C
C*MODULE NEBPATH *DECK NEBPX
C>
C>    @brief    NEBPATH main driver, Release 2
C>
C>    @details  Nudged Elastic Band (NEB) method (Release 2, Oct 2019)
C>              find a reaction path for specific reactant and product.
C>              Multiple transition states can be located along an NEB path.
C>
C>              PLAN: Release 3 --- String method to locate a transition state exactly.
C>                                  (December 2019)
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
c     **********************
C     Options for $NEB group
c     **********************
C    Caution: The coordinates of the reactant are given by $DATA
c             The coordinates of the product should be given by $DATAPD.
c             The atom order should be same in both reactant and product.
c             The product should be aligned as close to the reactant as possible,
c             Otherwise, some curious paths could be generated by this routine.
c             The molecular orientation is very important to obtain a reasonable
c             reaction path.               **************
c
c             For program debug, you can use EXETYP=check or EXETYP=nebpath
c             in $CONTRL group of your input file. This is related to the parameter
c             DBGLOG in this routine.
c
c             Basically, molecular symmetry cannot be used. However, if a reaction
c             path has symmetry on the whole way, you can set MOLSYM=.true.
c
c             MAXCYC is set to 500 as a default, but, generally speaking, the convergence
c             is currently very slow for the optimization of perpendicular gradient. So,
c             You may need to restart your job several times. For restart, $NEB and
c             $IMAGESX groups in *.dat file of the previous run need to be pasted into your
c             input file.
c
c             It would be difficult to reach the condition that all energy gradients are smaller
c             than opttol. You may decide in searching a saddle point, after the plot of
c             gradients along the path has two peaks (the minimum between two peaks could 
c             be the structure close to a target transition-state structure). 
c
c             Caution: keywords can have only 6 characters.
c
C     $NEB    IMAGES    = number of images along the NEB path (default=15)
c                         (maximum number of images is set to MXIMAGES=200)
c             MAXCYC    = maximum number of cycles for geometry optimization
c                         along the path perpendicular to the reaction path.
c                         (default = 500)
c
c             UNTCRD    = unit for the coordinates given by the $DATAPD and $DATAVI
c                         groups; ANGS or BOHR  (default = ANGS)
c             UNTCNT    = unit for the force constants e.g. SPFORC,OPTTOL
c                         ANGS or BOHR  (default = ANGS)
c
c             RESTRT    = Restart option.  See $IMAGESX.
c                         (default = .false.)
c             ISTART    = Number of cycles in the previous calculation
c
c             VIAPNT    = a via-point structure along the reaction path
c                         The coordinates are given in the $DATAVI group.
c                         (default = .false.)
c
c             TSLOCT    = locating a transition state structure
c                         (default = .false.)
c
c             OPTTOL    = Tolerance for the Force RMS to 
c                         (default = 5.0 [kcal/mol/angs])
c             OPMTOL    = Tolerance for the MAX Force RMS
c                         (default = 10.0 [kcal/mol/angs])
c
c             CRDTOL    = Tolerance for the distance displaced from each image along the path
c                         (default = 0.01 [angs])
c             CRMTOL    = Tolerance for the MAX distance displaced from each image along the path
c                         (default = 0.1 [angs])
c
c             DELTAT    = Distance multiplier 
c                         (default = 0.01 [angs/sqrt(kcal/mol)])
c
C             SPFORC    = force constant for a spring between two adjacent images
c                         (default = 500 [kcal/mol/(angs^2)])
c
c             IPMXCY    = IDPP interpolation NEB cycle (default = 500)
c             IPDLTT    = IDPP interpolation NEB DELTAT (default = 0.1)
c                                                    (olddefault = 0.4)
c             IPSPFC    = IDPP interpolation NEB SPFORC (default = 0.2)
c                                                    (olddefault = 0.01)
c             IPOPTL    = IDPP interpolation NEB OPTTOL (default = 0.01)
c
c             --------- This option should not be listed in the manual...
c             MORINT    = caution for molecular orientation
c                         (default = .false.)
c             MOLSYM    = say .true. if your reaction path has molecular symmetry
c                         along the whole way.  Otherwise, only "C1" can be used
c                         in the $DATA group.
c                         (default = .false.)
c             --------- The followings are unavailable right now
c
c             METHOD    = method of path finding (NEB or string)
c
c             OPTMZR    = method of a geometrical structure at each image
c                         quick-min  (default)
c                         steepest descent
c                         FIRE
c
c             FSTEND    = First end image condition
c             LSTEND    = Last end image condition
c
c             INTERP    = Interpolation method for making initial images
c
c             FITTNG    = Coordination fitting method every cycles
c
c             TANGNT    = Tangent vector definition
c
c             (more options will be added.)
c
c     $DATAPD           = the coordinates of the product
c                         atom name, atomic number, x, y, z for each atom
c             (should be given for all atoms, even if a molecular symmetry exists)
c
c     $DATAVI           = the coordinates of the via-point structure (optional)
c                         atom name, atomic number, x, y, z for each atom
c             (should be given for all atoms, even if a molecular symmetry exists)
c
c     ---------------
C     Dictionary file
c     ---------------
c     IREC = 1   Atomic coordinates
c     IREC = 2   Various energy quantities (Common /ENERGYS/)
c     IREC = 3   Gradient vector
c     IREC = 4   Hessian matrix (not use)
c     IREC = 15  Alpha orbitals
c     IREC = 19  Beta  orbitals
c
c     
c     IREC = 701 #image, coordinates, energy gradients, VEC at IMAGE 1
c     IREC = 702 #image, coordinates, energy gradients, VEC at IMAGE 2
c     IREC = 703 #image, coordinates, energy gradients, VEC at IMAGE 3
c     IREC = 704 #image, coordinates, energy gradients, VEC at IMAGE 4
c
c     IREC = 715 #image, coordinates, energy gradients, VEC at IMAGE 15 (default)
c
c     IREC = 730 #image, coordinates, energy gradients, VEC at IMAGE 30 (if necessary)
c
c     IREC = 900 #image, coordinates, energy gradients, VEC at IMAGE 200 (maximum)
c     https://www.msg.chem.iastate.edu/gamess/GAMESS_Manual/prog.pdf
c
C>
      SUBROUTINE NEBPX
      implicit none

      !-----PARAMETER BLOCK----
      integer, parameter :: MXATM=2000, MXA3=3*MXATM, MXAO=8192
      integer, parameter :: MXFRG=1050, MXNCF=6*MXFRG, MXIMAGES=200
      integer, parameter :: MXPT=2000, MXFGPT=12000
      integer, parameter :: MXDFG=5, MXDPPT=MXFRG*MXDFG*12
      double precision, parameter :: ZERO=0.00D+00
      double precision, parameter :: ONE=1.00D+00
      double precision, parameter :: TWO=2.00d+00
      double precision, parameter :: TOANGS=0.52917721092D+00
      double precision, parameter :: TOKCAL=627.509474277194D+00
      !DOI:10.1103/RevModPhys.84.1527
      !DOI:10.1063/1.4724320
      !DOI:10.1351/pac197951010001
      !-----PARAMETER BLOCK----

      !-----COMMON BLOCK-----
      double precision :: X
      COMMON /FMCOM / X(1)
c
      double precision :: ENERGY, EGRAD
      COMMON /FUNCT / ENERGY,EGRAD(MXA3)
c
      integer :: NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      double precision :: ZAN,C
      integer :: IR,IW,IP,IS,IPK,IDAF,NAV,IODA
      double precision :: ZMASS
      integer :: ME,MASTER,NPROC,IBTYP,IPTIM
      logical :: GOPARR, DSKWRK, MASWRK

      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     &                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c
      double precision :: TITLE,ANAM,BNAM,BFLAB
      double precision :: RUNTYP,EXETYP
      integer :: NEVALS,NGLEVL,NHLEVL
      double precision :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      integer :: MPLEVL,MPCTYP
      double precision :: GROUP,COMPLEX
      integer :: IGROUP,NAXIS,ILABMO
      logical :: ABEL

      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     &                MPLEVL,MPCTYP
      COMMON /SYMMOL/ GROUP,COMPLEX,IGROUP,NAXIS,ILABMO,ABEL
      !-----COMMON BLOCK-----

      !-----INPUT READING BLOCK----
      double precision :: SNEB
      DATA SNEB/8HNEB     /
      logical :: DBGLOG
      integer :: IMAGES, MAXCYC
      double precision :: METHOD
      logical :: RESTRT
      integer :: ISTART
      double precision :: UNTCRD, UNTCNT
      logical :: MOLSYM, MORINT, VIAPNT
      double precision :: OPTMZR
      logical :: TSLOCT
      double precision :: INTERP, FITTNG, FSTEND, LSTEND
      double precision :: DELTAR
      integer :: SHTHRE
      double precision :: TANGNT, DELTAT, SPFORC, OPTTOL
      double precision :: OPMTOL, CRDTOL, CRMTOL
      integer :: NUMHIS
      integer :: IPMXCY !IDPP
      double precision :: IPDLTT, IPSPFC, IPOPTL !IDPP
      integer :: THRE01, THRE02
      integer, parameter :: NNAM=33 !How many options NAMEIO routine reads
      character(len=8) :: QNAM(NNAM)
      DATA QNAM/8HDBGLOG  ,8HIMAGES  ,8HMAXCYC  ,8HMETHOD  ,
     &          8HRESTRT  ,8HISTART  ,8HUNTCRD  ,8HUNTCNT  ,
     &          8HMOLSYM  ,8HMORINT  ,8HVIAPNT  ,8HOPTMZR  ,
     &          8HTSLOCT  ,8HINTERP  ,8HFITTNG  ,8HFSTEND  ,
     &          8HLSTEND  ,8HDELTAR  ,8HSHTHRE  ,8HTANGNT  ,
     &          8HDELTAT  ,8HSPFORC  ,8HOPTTOL  ,8HOPMTOL  ,
     &          8HCRDTOL  ,8HCRMTOL  ,8HNUMHIS  ,8HIPMXCY  ,
     &          8HIPDLTT  ,8HIPSPFC  ,8HIPOPTL  ,8HTHRE01  ,
     &          8HTHRE02  /
C     !Caution: only 6 characters can be used.
C     !Caution: Space is important for HOLLERITH_CONSTANT.

      integer :: KQNAM(NNAM) !QNAM's data type
      DATA KQNAM/0,1,1,5, 
     &           0,1,5,5,
     &           0,0,0,5,
     &           0,5,5,5,
     &           5,3,1,5,
     &           3,3,3,3,
     &           3,3,1,1,
     &           3,3,3,1,
     &           1/
C
C     !         0=logical        (e.g. DIRSCF)
C     !         1=integer        (e.g. MULT)
C     !         3=floating point (e.g. OPTTOL)
C     !         5=characters     (e.g. SCFTYP)
C
      !-----INPUT READING BLOCK----

      !-----PATHOPT BLOCK-----
      integer :: nIMAGES
      double precision :: CHECK
      double precision :: UNTANG, UNTBHR
      double precision :: NEBPATH, QUICKMIN
      double precision :: UNDEFINED, ANGSTROMS
      double precision :: C1
      double precision :: GRADIENT
      DATA CHECK     /8HCHECK   /
      DATA UNTANG    /8HANGS    /
      DATA UNTBHR    /8HBOHR    /
      DATA NEBPATH   /8HNEBPATH /
      DATA QUICKMIN  /8HQUICKMIN/
      DATA UNDEFINED /8H        /
      DATA ANGSTROMS /8HANGS    /
      DATA C1        /8HC1      /
      DATA GRADIENT  /8HGRADIENT/

      integer :: IX(MXATM*MXIMAGES) !atomic number? 
      double precision :: PROCRD(MXATM*4), VIACRD(MXATM*4)

      logical :: DEBUG
      logical :: abortflag
      logical :: convflag
      
      integer :: JRET !used for NAMEIO routine
      integer :: IPTRAJ !Unit Number of trajectory file (4)
      double precision :: ftol
      double precision :: dsplim ! displacement limit of optimizer

      integer :: icnt !Error counter of coordinate reading
      integer :: nbx, nby !Half number of images used in via-point mode
      double precision :: qdt !modified quickdt
      integer :: iswitch !convergence flag
      integer :: iimage
      integer :: n3, n4
      integer :: i, i0, i1, i2, ij, j, j0, n
      integer :: icycle, jcycle
      !-----PATHOPT BLOCK-----

      !-----MEMORY MAPPING----
      integer :: LOADFM, LIMAGES, LCWORK, LVWORK, LC1WORK, LC2WORK
      integer :: LD1WORK, LD2WORK, LENGY, LGRAD, LSFORC, LDSTNT, LVELOC
      integer :: LBFORC, LBDIST, LTAU1, LTAU2, LSTOREI, LSTORE, LFTRMS
      integer :: LFTMAX, LHISX, LHISF, LINVHES, LASTM, NEED
      integer :: JFTMAX !MEMORY ADDRESS for restart
c     LFTrms = gradient RMS at each image                (IMAGES)
      !-----MEMORY MAPPING----

C
C     !----- Nudged Elastic Band pathfinder -----
      if(maswrk) then
            write(iw,"(
     &/,10X,30(1H-)/10X,'Nudged Elastic Band Pathfinder'/
     &         10X,30(1H-),
     &/,10x,'implemented in March 2019',
     &/,10x,' by Nozomi Sawada, Mamoru Haruta,',
     &      ' Toshio Asada, and Shiro Koseki,',
     &/,10x,'Osaka Prefecture University, Japan.',
     &/,10x,'Reference: Chem Phys Lett in progress.')")
      end if
C
      N4 = 4 * NAT
c          iat,x,y,z
      n3 = nat*3
c
c     !---------------------------------------
c     !Defaults of options...
c
      DBGLOG = .false.        !debug log
      IMAGES = 15             ! MXIMAGES = 200
      METHOD = 'NEB'
      TANGNT = 'ORIGINAL'
      MAXCYC = 500

      RESTRT = .false.
      ISTART = 0

      UNTCRD = UNTANG
      UNTCNT = UNTANG

      MOLSYM = .false.
      MORINT = .false.
      VIAPNT = .false.
      OPTMZR = 'QUICKMIN'

      TSLOCT = .false.
      INTERP = 'IDPP'
      FITTNG = 'ANGULAR'

      FSTEND = 'FIXED'
      LSTEND = 'FIXED'
      DELTAR = 0.0d+00              !For Adaptive-end
      SHTHRE = 1                    !For Adaptive-end

      DELTAT = 0.01d+00             ![angs/sqrt(kcal/mol)]
            != 0.47337902482973d+00 ![bohr/sqrt(hartree)]

      SPFORC = 500d+00
      !SPFORC = 300.9d+00            ![kcal/mol/(angs^2)]
            != 0.13427778430386d+00 ![hartree/(bohr^2)]

      OPTTOL = 5.0d+00              ![kcal/mol/angs]
            != 0.00421648781900d+00 ![hartree/bohr]
      OPMTOL = 10.0d+00             ![kcal/mol/angs]
      CRDTOL = 0.01d+00             ![angs]
      CRMTOL = 0.1d+00              ![angs]

      IPMXCY = 3000          !IDPP NEB Maxcycle
      IPDLTT = 0.1d+00       !IDPP quickdt
      IPSPFC = 0.01d+00      !IDPP springforce
      IPOPTL = 0.01d+00      !IDPP tolerance

      NUMHIS = 10            ! number of history data (>1)
      THRE01 = 10            ! for optimizer
      THRE02 = 20            ! for optimizer
c     !------------------------------------------

c     FTOL   = 0.050d+00      ! this is not an input option...
c     FTOL   = 0.030d+00      ! this is not an input option...
      FTOL   = 0.010d+00      ! this is not an input option...
c
      DSPLIM = 0.145         ! displacement limit of BFGS coord update.
c
c
c     !------------------------------------------
      PROCRD(1:n4) = zero
      VIACRD(1:n4) = zero
c
c
c     !------------------------------------------
C     !      READ NAMELIST $NEB
      JRET = 0
      CALL NAMEIO(IR, JRET, SNEB, NNAM, QNAM, KQNAM,
     &            DBGLOG, IMAGES, MAXCYC, METHOD,
     &            RESTRT, ISTART, UNTCRD, UNTCNT,
     &            MOLSYM, MORINT, VIAPNT, OPTMZR,
     &            TSLOCT, INTERP, FITTNG, FSTEND,
     &            LSTEND, DELTAR, SHTHRE, TANGNT,
     &            DELTAT, SPFORC, OPTTOL, OPMTOL,
     &            CRDTOL, CRMTOL, NUMHIS, IPMXCY,
     &            IPDLTT, IPSPFC, IPOPTL, THRE01,
     &            THRE02, 0,0,0,
     &            0,0,0,0, 0,0,0,0,
     &            0,0,0,0, 0,0,0,0,
     &            0,0,0,0, 0,0,0,0,
     &            0,0,0,0, 0,0,0,0,
     &            0,0)
      !NAMEIO can read 70 variables.
      if (JRET.gt.1) then
          if(maswrk) then
              write(iw,'(a)')'NAMELIST $NEB SYNTAX ERROR FOUND.'
          end if
          call abrt
      end if
      call DDI_sync(32001)
c
c     !------------------------------------------
c     !Check the input options...
!      if(IMAGES.eq.0) IMAGES=15
!      if(maxcyc.eq.0) maxcyc=500
      if(UNTCRD.eq.UNDEFINED) UNTCRD=ANGSTROMS
!      if(SPFORC.eq.zero) SPFORC=0.5d+00
!      if(DELTAT.eq.zero) DELTAT=0.2d+00
!      if(OPTTOL.eq.zero) opttol = 0.0010d+00
!      if(crdtol.eq.zero) crdtol = 20.0d+00     ! a largest distance...?
c
c     !------------------------------------------
c     !log setting...
      abortflag = .false.
      if(DBGLOG) then
          debug = .true.
      else
          debug = .false. 
      end if
      if(EXETYP.eq.NEBPATH) then
          debug=.true.
      end if
c

c     !------------------------------------------
c     !Print out options and coordinates...
      if(maswrk) then
          write(iw,"(/,
     & 5X,'$NEB OPTIONS',/,5X,'------------',
     & /,' Parallel computation                   (GOPARR) = ',L1,
     & /,' Output verbose log for debug           (DBGLOG) = ',L1,
     & /,' Number of images                       (IMAGES) = ',i8,
     & /,' Maximum cycle number                   (MAXCYC) = ',i8,
     & /,' Method of path optimizing              (METHOD) = ',a8,
     & /,' Restart option                         (RESTRT) = ',L1,
     & /,' Number of the cycles                   (ISTART) = ',i8,
     & /,' Unit for coordinates                   (UNTCRD) = ',a8,
     & /,' Unit for constants                     (UNTCNT) = ',a8,
     & /,' Caution for molecular symmetry         (MOLSYM) = ',L1,
     & /,' Caution for molecular orientation      (MORINT) = ',L1,
     & /,' Via-point structure                    (VIAPNT) = ',L1,
     & /,' Optimizer                              (OPTMZR) = ',a8,
     & /,' Transition-state search                (TSLOCT) = ',L1,
     & /,' Interpolation method for making images (INTERP) = ',a8,
     & /,' Coordination fitting between images    (FITTNG) = ',a8,
     & /,' First end image condition              (FSTEND) = ',a8,
     & /,' Last end image condition               (LSTEND) = ',a8,
     & /,' Delta r for Adaptive-end               (DELTAR) = ',f20.10,
     & /,' Dist changing thre for Adaptive-end    (SHTHRE) = ',i8,
     & /,' Tangent vector definition              (TANGNT) = ',a8
     & )")
     &   GOPARR, DBGLOG, IMAGES, MAXCYC,
     &   METHOD, RESTRT, ISTART, UNTCRD,
     &   UNTCNT, MOLSYM, MORINT, VIAPNT,
     &   OPTMZR, TSLOCT, INTERP, FITTNG,
     &   FSTEND, LSTEND, DELTAR, SHTHRE, TANGNT
      end if
      if (UNTCNT == 'ANGS') then
          !Convert
          DELTAT = DELTAT*(1/TOANGS * 1/sqrt(1/TOKCAL))
          SPFORC = SPFORC/TOKCAL*TOANGS*TOANGS
          OPTTOL = OPTTOL/TOKCAL*TOANGS
          OPMTOL = OPMTOL/TOKCAL*TOANGS
          CRDTOL = CRDTOL/TOANGS
          CRMTOL = CRMTOL/TOANGS
      end if
      if(maswrk) then
          if (UNTCNT == 'ANGS') then
              write(iw,"(
     &   ' Distance multiplier for quick-min      (DELTAT) = ',f10.5,
     &   ' [angs/sqrt(kcal/mol)]',
     & /,'                                                 = ',f10.5,
     &   ' [bohr/sqrt(hartree)]',
     & /,' Spring force constant                  (SPFORC) = ',f10.5,
     &   ' [kcal/mol/(angs^2)]',
     & /,'                                                 = ',f10.5,
     &   ' [hartree/(bohr^2)]',
     & /,' Tolerance for geometrical optimization (OPTTOL) = ',f10.5,
     &   ' [kcal/mol/angs]',
     & /,'                                                 = ',f10.5,
     &   ' [hartree/bohr]',
     & /,' Tolerance MAX geometrical optimization (OPMTOL) = ',f10.5,
     &   ' [kcal/mol/angs]',
     & /,'                                                 = ',f10.5,
     &   ' [hartree/bohr]',
     & /,' Tolerance for coordination displacement(CRDTOL) = ',f10.5,
     &   ' [angs]',
     & /,'                                                 = ',f10.5,
     &   ' [bohr]',
     & /,' Tolerance MAX coordination displacement(CRMTOL) = ',f10.5,
     &   ' [angs]',
     & /,'                                                 = ',f10.5,
     &   ' [bohr]'
     & )")
     &   DELTAT/(1/TOANGS * 1/sqrt(1/TOKCAL)),DELTAT, 
     &   SPFORC*TOKCAL/TOANGS/TOANGS,         SPFORC, 
     &   OPTTOL*TOKCAL/TOANGS,                OPTTOL, 
     &   OPMTOL*TOKCAL/TOANGS,                OPMTOL, 
     &   CRDTOL*TOANGS,                       CRDTOL, 
     &   CRMTOL*TOANGS,                       CRMTOL
          else if(UNTCNT == 'BOHR') then
              write(iw,"(
     &   ' Distance multiplier for quick-min      (DELTAT) = ',f10.5,
     &   ' [bohr/sqrt(hartree)]',
     & /,'                                                 = ',f10.5,
     &   ' [angs/sqrt(kcal/mol)]',
     & /,' Spring force constant                  (SPFORC) = ',f10.5,
     &   ' [hartree/(bohr^2)]',
     & /,'                                                 = ',f10.5,
     &   ' [kcal/mol/(angs^2)]',
     & /,' Tolerance for geometrical optimization (OPTTOL) = ',f10.5,
     &   ' [hartree/bohr]',
     & /,'                                                 = ',f10.5,
     &   ' [kcal/mol/angs]',
     & /,' Tolerance MAX geometrical optimization (OPMTOL) = ',f10.5,
     &   ' [hartree/bohr]',
     & /,'                                                 = ',f10.5,
     &   ' [kcal/mol/angs]',
     & /,' Tolerance for coordination displacement(CRDTOL) = ',f10.5,
     &   ' [bohr]',
     & /,'                                                 = ',f10.5,
     &   ' [angs]',
     & /,' Tolerance MAX coordination displacement(CRMTOL) = ',f10.5,
     &   ' [bohr]',
     & /,'                                                 = ',f10.5,
     &   ' [angs]'
     & )")
     &   DELTAT, DELTAT/(1/TOANGS * 1/sqrt(1/TOKCAL)),
     &   SPFORC, SPFORC*TOKCAL/TOANGS/TOANGS,
     &   OPTTOL, OPTTOL*TOKCAL/TOANGS,
     &   OPMTOL, OPMTOL*TOKCAL/TOANGS,
     &   CRDTOL, CRDTOL*TOANGS,
     &   CRMTOL, CRMTOL*TOANGS
          else
              write(iw,'(3a)')'UNTCNT = ',UNTCNT,' is invalid.'
              call abrt
          end if
          write(iw,"(
     &   ' IDPP interpolation NEB MAXCYC          (IPMXCY) = ',i8,
     & /,' IDPP interpolation NEB DELTAT          (IPDLTT) = ',f10.5,
     & /,' IDPP interpolation NEB SPFORC          (IPSPFC) = ',f10.5,
     & /,' IDPP interpolation NEB OPTTOL          (IPOPTL) = ',f10.5,
     & /)")IPMXCY, IPDLTT, IPSPFC, IPOPTL
      end if
      call DDI_sync(32002)
c 
      !---------------------------------------------------------------------
      !-- Variable Adaptor 
      !    because of limitation of length of read variable.
      nimages = IMAGES !input variable to internal variable

      !---------------------------------------------------------------------
      !-- Validity check
      if(IMAGES>MXIMAGES) then
          write(iw,'(a,i0,a)')'IMAGES must be less than ',MXIMAGES,'...'
          call abrt
      end if
      if(NUMHIS<1) then
          write(iw,'(a)')'NUMHIS must be grater than 1...'
          call abrt
      end if
      if (TSLOCT.and.IMAGES <= 2 ) then
          write(iw,'(a)')
     &        'TSLOCT : For TS searching, at least 3 images are needed.'
          call abrt
      end if
      if(METHOD/='NEB') then
          write(iw,'(3a)')'METHOD : ',METHOD,' is not supported now.'
          write(iw,'(a)')'Wait for next release...'
          call abrt
      end if
      !if(OPTMZR/='QUICKMIN') then
      !    write(iw,'(3a)')'OPTMZR : ',OPTMZR,' is not supported now.'
      !    write(iw,'(a)')'Wait for next release...'
      !    call abrt
      !end if
      if(INTERP/='IDPP') then
          write(iw,'(3a)')'INTERP : ',INTERP,' is not supported now.'
          write(iw,'(a)')'Wait for next release...'
          call abrt
      end if
      if(FITTNG/='ANGULAR') then
          write(iw,'(3a)')'FITTNG : ',FITTNG,' is not supported now.'
          write(iw,'(a)')'Wait for next release...'
          call abrt
      end if
      !if(FSTEND/='FIXED') then
      !    write(iw,'(3a)')'FSTEND : ',FSTEND,' is not supported now.'
      !    write(iw,'(a)')'Wait for next release...'
      !    call abrt
      !end if
      !if(LSTEND/='FIXED') then
      !    write(iw,'(3a)')'LSTEND : ',LSTEND,' is not supported now.'
      !    write(iw,'(a)')'Wait for next release...'
      !    call abrt
      !end if
      if(SHTHRE<1) then
          write(iw,'(a)')'SHTHRE must be grater than 1...'
          call abrt
      end if
      if(TANGNT/='ORIGINAL') then
          write(iw,'(3a)')'TANGNT : ',TANGNT,' is not supported now.'
          write(iw,'(a)')'Wait for next release...'
          call abrt
      end if


      !---------------------------------------------------------------------
      if(maswrk) then
          write(iw,'(a)')'Coordinates of the reactant [bohr]...'
          i0=0
          do i=1,nat
              write(iw,'(1x,a8,a2,1x,F5.1,3F18.10)')
     &              ANAM(i),BNAM(i),ZAN(i),
     &              (C(j,i),j=1,3)
!     &              ,ZMASS(i),IAN(i)
              i0=i0+3
          enddo
c
      !-----Symmetry check--------------------------------------------------
          if(GROUP.ne.C1) then
              if(.not.molsym) then
                  if(maswrk) then
                      write(iw,"(
     &//,57('*'),/,57('*'),
     &/,'**                                                     **',
     &/,'** Caution: if your reaction path has molecular        **',
     &/,'** symmetry on the whole way, you can used molecular   **',
     &/,'** symmetry.  Then, you have to re-submit your job     **',
     &/,'** with MOLSYM = .true. in the $NEB group.             **',
     &/,'**                                                     **',
     &/,57('*'),/,57('*'),/)")
                  end if
                  call abrt
              endif
          endif
c
      !-----read product coordinate-----------------------------------------
          call PATH_readcoord(ir,iw,' $DATAPD',nat,procrd,maswrk,debug)
c                                    12345678
c
          write(iw,'(a)')'Coordinates of the product [bohr]...'
          i0=0
          do i=1,NAT
             !--Convert Unit [bohr] to [angstrom]
              if(UNTCRD.eq.ANGSTROMS) then
                  do j=2,4
                      PROCRD(i0+j)= PROCRD(i0+j)/TOANGS
                  enddo
              endif
              write(iw,'(1x,a8,a2,1x,F5.1,3F18.10)')
     &              ANAM(i),BNAM(i),
     &              (PROCRD(i0+j),j=1,4)
!     &              ,ZMASS(i)
             I0=I0+4
          enddo
c
      !-----read via-point coordinate-----------------------------------------
          if(VIAPNT) then
              call PATH_readcoord
     &             (ir,iw,' $DATAVI',nat,viacrd,maswrk,debug)
c                          12345678
              write(iw,'(a)')
     &             'Coordinates of the via-point structure [bohr]...'
              i0=0
              do i=1,NAT
                  !--Convert unit [bohr] to [angstrom]
                  if(UNTCRD.eq.ANGSTROMS) then
                      do j=2,4
                           VIACRD(i0+j)= VIACRD(i0+j)/TOANGS
                      enddo
                  endif
                  write(iw,'(1x,a8,a2,1x,F5.1,3F18.10)') 
     &                 ANAM(i),BNAM(i),
     &                 (VIACRD(i0+j),j=1,4)
!     &                 ,ZMASS(i)
                  i0=i0+4
              enddo
          endif
      endif
C
      !-----DDI broadcast-----------------------------------------------------
      call DDI_sync(32006)
      if(GOPARR) then
          call DDI_BCAST(320050,'F',PROCRD,n4,0)
          call DDI_BCAST(320051,'F',VIACRD,n4,0)
      endif
c
      !-----Examine atom order...-------------------------------------------
c     !     Reactant and Product
      IF(MASWRK) then
           write(iw,'(/,a)')
     &          '* Examine atom order of the reactant and product...'
      end if
      i0 = 0
      icnt = 0
      do i=1,nat
          if(procrd(i0+1).ne.zan(i)) then
              icnt = icnt+1
              IF(MASWRK) then
                   write(iw,'(a,i5,2f5.1)')
     &            'Error of atom order   ---',i,zan(i),procrd(i0+1)
              end if
          endif
          i0 = i0+4
      enddo
      IF(MASWRK) then
           if (icnt == 0) then
           write(iw,'(a)') 'The atom orders are fine...'
           else 
           write(iw,'(a,i0,a)')
     &     'Caution: the number of different atom orders is',
     &     icnt,' (icnt).'
           write(iw,'(a,i0)')
     &     'Error: atom orders are different... icnt=',icnt
           call abrt
           end if
      end if
      call DDI_sync(32007)

      call flshbf(iw)

      !call DDI_sync(32010)

c
c
c.MWS[20190316 ---------------------------------------------
c     call ddi_nnode(nnode,mynode)
c     write(iw,'(a,2i15)') 'Debug: nnode, mynode=',nnode,mynode
c     CALL DDI_NPROC(DDI_NP,DDI_ME)
c     write(iw,'(a,2i5)') 'Debug: DDI_NP =',DDI_NP,DDI_ME
c
c     CALL DDI_SMP_NPROC(SMP_NP,SMP_ME)
c     write(iw,'(a,2i5)') 'Debug: SMP_NP,SMP_ME=',SMP_NP,SMP_ME
C
c     CALL DDI_SMP_SYNC()
c     call DDI_sync(32008)
c
c     if(debug) then
c        if(maswrk) write(iw,*) 'I have reached NEBpath-3-1'
c        call flshbf(iw)
c        call ddi_sync(15002)
c        if(maswrk) write(iw,*) 'all processes reached NEBpath-3-1'
c        call flshbf(iw)
c        MLGDDI
c        NGLEVL
c        CALL DDI_LEVEL(IMPLEMENTATION)
cx       CALL DDI_MEMORY(MEMORY,MEMDDIX,EXETYP)
c        if(maswrk) then
c           write(iw,'(a,i5)')  'IMPLEMENTATION =',IMPLEMENTATION
cx          write(iw,'(a,i15)') 'MEMORY  =',MEMORY
cx          write(iw,'(a,i15)') 'MEMDDIX =',MEMDDIX
c           endif
c        endif
c     call flshbf(iw)
c     call flshbf(ip)
c     call flshbf(is)
c     call flshbf(IPTRAJ)
c     call flshbf(idaf)
c     call DDI_sync(32009)
c.MWS[20190316 ---------------------------------------------
c
c
c
      !-----Examine atom order...-------------------------------------------
c     !     Reactant and Via-point structure, if necessary
      if(VIAPNT) then
          IF(MASWRK) then
              write(iw,'(/,a)')
     &           '* Examine atom order of the reactant and via-point...'
          end if
          i0 = 0
          icnt = 0
          do i=1,nat
              if(procrd(i0+1).ne.zan(i)) then
                  icnt = icnt+1
                  IF(MASWRK) then
                      write(iw,'(a,i5,2f5.1)')
     &                 'Error of atom order   ---',i,zan(i),viacrd(i0+1)
                  end if
              endif
              i0 = i0+4
          enddo
          IF(MASWRK) then
              if (icnt == 0) then
                  write(iw,'(a)') 'The atom orders are fine...'
              else 
                  write(iw,'(a,i0,a)')
     &                'Caution: the number of different atom orders is',
     &            icnt,' (icnt).'
                  write(iw,'(a,i0)')
     &                 'Error: atom orders are different... icnt=',icnt
                  call abrt
              end if
          end if
      endif

      !-----memory allocation ----------------------------------------------
c     !NAT = number of atoms
c     !ICH = molecular charge
c     !MUL = spin multiplicity
c     !NUM = number of CARTESIAN GAUSSIAN BASIS FUNCTIONS
c     !NE  = number of electrons
c     !NA  = number of alpha electrons
c     !NB  = number of beta electrons
c     !ZAN = nuclear charges of atoms
c     !C   = coordinates of atoms
c     !IAN = atomic numbers of atoms
c     !if(maswrk.and.debug) write(iw,'(a,3i5)') 'NAT,NUM,NE =',nat,num,ne
c
      CALL VALFM(LOADFM)
      LIMAGES  = LOADFM  + 1
      LCWORK  = LIMAGES  + 3*NAT*IMAGES
      LVWORK  = LCWORK  + 3*NAT
      LC1WORK = LVWORK  + 3*NAT
      LC2WORK = LC1WORK + 3*NAT
      LD1WORK = LC2WORK + 3*NAT
      LD2WORK = LD1WORK + NAT*NAT
      LENGY   = LD2WORK + NAT*NAT
      LGRAD   = LENGY   + IMAGES
      LSFORC  = LGRAD   + IMAGES
      LDSTNT  = LSFORC  + IMAGES
      LVELOC  = LDSTNT  + IMAGES
      LBFORC  = LVELOC  + 3*NAT*IMAGES
      LBDIST  = LBFORC  + 3*NAT*IMAGES
      LTAU1   = LBDIST  + NAT*NAT*IMAGES
      LTAU2   = LTAU1   + 3*NAT
      LSTOREI = LTAU2   + 3*NAT
      LSTORE  = LSTOREI + IMAGES
      LFTrms  = LSTORE  + 3*NAT +3*NAT +NUM*NUM*2
      LFTmax  = LFTrms  + IMAGES
      !LASTM   = LFTmax  + maxcyc !0604HARUTA original
      LHISX    = LFTmax  + MAXCYC !0604HARUTA added for DIIS
      LHISF    = LHISX    + 3*NAT*IMAGES*NUMHIS !0604HARUTA added for DIIS
      LINVHES  = LHISF    + 3*NAT*IMAGES*NUMHIS !0604HARUTA added for BFGS
      LASTM   = LINVHES  + 3*NAT*3*NAT*IMAGES*IMAGES !0604HARUTA
c                         Coord  Grad   VEC
c     !IREC = 701 #image, coordinates, energy, VEC(a&b) at IMAGE 1
c
      NEED   = LASTM - LOADFM - 1
      CALL GETFM(NEED)
      call DDI_sync(32012)
c
c     !X(LIMAGES)  = Coordinates for all images                 (3*NAT*IMAGES)
c     !X(LCWORK)  = Work area of coordinates                  (3*NAT)
c     !X(LVWORK)  = Work area of coordinates                  (3*NAT)
c     !X(LC1WORK) = Work area of coordinates for rotation     (3*NAT)
c     !X(LC2WORK) = Work area of coordinates for rotation     (3*NAT)
c     !X(LD1WORK) = Work area of distance matrix for rotation (NAT*NAT)
c     !X(LD2WORK) = Work area of distance matrix for rotation (NAT*NAT)
c     !X(LENGY)   = Total energy at each image                 (IMAGES)
c     !X(LGRAD)   = RMS gradient at each image                 (IMAGES)
c     !X(LSFORC)  = Spring force constant                     (IMAGES)
c     !X(LDSTNT)  = distance between the images                (IMAGES)
c     !X(LVELOC)  = velocity at each image                     (3*NAT*IMAGES)
c     !X(LBFORC)  = force at each image                        (3*NAT*IMAGES)
c     !X(LBDIST)  = distance matrix at each image              (NAT*NAT*IMAGES)
c     !X(LTAU1)   = work area in IDPP                         (3*NAT)
c     !X(LTAU2)   = work area in IDPP                         (3*NAT)
c     !X(LSTOREI) = Record number of the dictionary file      (IMAGES)
c     !X(LSTORE)  = work area for Coord, Grad, and VEC        (3*NAT +3*NAT +NUM*NUM*2)
c     !IREC = 701 #image, coordinates, energy, VEC(a&b) at IMAGE 1
c     !X(LFTrms)  = gradient RMS at each image                 (IMAGES)
c     !X(LFTmax)  = maximum of perpendicular gradient         (maxcyc)
c     !X(LHISX)    = History of Coordinate using for DIIS(3*NAT*IMAGES*numhis) !HARUTA
c     !X(LHISF)    = History of Gradient using for BFGS(3*NAT*IMAGES*numhis) !HARUTA
c     !X(LINVHES)  = Inverted Hessian using for BFGS (3*NAT*3*NAT*IMAGES*IMAGES) !HARUTA
c
      if(maswrk.and.debug) then
         write(iw,9060) LOADFM,
     &         LIMAGES,(LCWORK-LIMAGES),   LCWORK,(LVWORK-LCWORK),
     &         LVWORK,(LC1WORK-LVWORK),  LC1WORK,(LC2WORK-LC1WORK),
     &         LC2WORK,(LD1WORK-LC2WORK),LD1WORK,(LD2WORK-LD1WORK),
     &         LD2WORK,(LENGY-LD2WORK),  LENGY,(LGRAD-LENGY),
     &         LGRAD,(LSFORC-LGRAD),     LSFORC,(LDSTNT-LSFORC),
     &         LDSTNT,(LVELOC-LDSTNT),   LVELOC,(LBFORC-LVELOC),
     &         LBFORC,(LBDIST-LBFORC),   LBDIST,(LTAU1-LBDIST),
     &         LTAU1,(LTAU2-LTAU1),      LTAU2,(LSTOREI-LTAU2),
     &         LSTOREI,(LSTORE-LSTOREI), LSTORE,(LFTrms-LSTORE),
     &         LFTrms,(LFTmax-LFTrms),   LFTmax,(LHISX-LFTmax),
     &         LHISX,(LHISF-LHISX),         LHISF,(LINVHES-LHISF),
     &         LINVHES,(LASTM-LINVHES),
!     &         LFTrms,(LFTmax-LFTrms),   LFTmax,(LASTM-LFTmax),!0605HARUTA
     &         LASTM
      end if
 9060 format(/,'*** Debug: memory allocation...',5x,'LOADFM=',i15,
     */,5x,'LIMAGES  =',i15,i8,'   LCWORK  =',i15,i8,
     */,5x,'LVWORK  =',i15,i8,'   LC1WORK =',i15,i8,
     */,5x,'LC2WORK =',i15,i8,'   LD1WORK =',i15,i8,
     */,5x,'LD2WORK =',i15,i8,'   LENGY   =',i15,i8,
     */,5x,'LGRAD   =',i15,i8,'   LSFORC  =',i15,i8,
     */,5x,'LDSTNT  =',i15,i8,'   LVELOC  =',i15,i8,
     */,5x,'LBFORC  =',i15,i8,'   LBDIST  =',i15,i8,
     */,5x,'LTAU1   =',i15,i8,'   LTAU2   =',i15,i8,
     */,5x,'LSTOREI =',i15,i8,'   LSTORE  =',i15,i8,
     */,5x,'LFTrms  =',i15,i8,'   LFTmax  =',i15,i8,
     */,5x,'LHISX   =',i15,i8,'   LHISF   =',i15,i8,
     */,5x,'LINVHES =',i15,i8,
     */,5x,'LASTM   =',i15)
      call DDI_sync(32013)
c
c     !---------------------------
c     !Clear array...
      if(maswrk.and.debug) then
         write(iw,'(a)') 'Debug: clear the arrays; ',
     &         'X(LIMAGES), X(LVELOC), and X(LFTmax)...'
      end if
      call vclr(X(LIMAGES),1,NEED)
      call vclr(X(LHISX),1,3*NAT*IMAGES*NUMHIS) !0604HARUTA
      call vclr(X(LHISF),1,3*NAT*IMAGES*NUMHIS) !0604HARUTA
      call vclr(X(LINVHES),1,3*NAT*3*NAT*IMAGES*IMAGES) !0604HARUTA
      call vclr(X(LVELOC),1,3*nat*IMAGES)
      call vclr(X(LFTmax),1,maxcyc)
      call DDI_sync(32014)
c
c     !---------------------------
c     !Open a trajectory file...
      IPTRAJ=4
      CALL SEQOPN(IPTRAJ,'TRAJECT','NEW',.FALSE.,'FORMATTED')
      call DDI_sync(32015)
c

c     !----------------------------------------
c     !Restart...   need array...
c     !RESTRT   = Restart option.  See $IMAGESX.
      if(RESTRT) then
          if(maswrk) then
              write(iw,'(a,a)') '*** Restart option is enabled. '
     &                ,'Will read the data from $IMAGESX group ... ***'
              call PATH_read_restart(ir,iw,nat,zan,IMAGES,
     &             X(LIMAGES),X(LENGY),X(LGRAD),
     &             X(LVELOC),maswrk,debug)
              write(iw,'(a,a)') '*** Read the current coordinates,'
     &                        ,' energy, and velocity at each image ***'
          endif
          call DDI_sync(32016)
          if(GOPARR) then
              call DDI_BCAST(320150,'F',zan,nat,0)
              call DDI_BCAST(320151,'F',X(LIMAGES),n3*nimages,0)
              call DDI_BCAST(320152,'F',X(LENGY),nimages,0)
              call DDI_BCAST(320153,'F',X(LGRAD),nimages,0)
              call DDI_BCAST(320154,'F',X(LVELOC),n3*nimages,0)
          endif

      elseif(.not.RESTRT) then

c         !----------------------------------------
c         !IMAGES #1      = reactant
c*        !call DCOPY(n3,c,x(LCWORK),1)
          i0 = LIMAGES
          do i=1,nat
              do j=1,3
                  x(i0) = c(j,i)
                  i0 = i0+1
              enddo
          enddo
c
c         !IMAGES #IMAGES = product
          i0 = LIMAGES + NAT*3*(IMAGES-1)
          j0 = 0
          do i=1,nat
              j0 = j0+1
              do j=1,3
                  j0 = j0+1
                  x(i0) = procrd(j0)
                  i0 = i0+1
              enddo
          enddo
c
c         !IMAGES #IMAGES/2+1 = via-point
          if(VIAPNT) then
              i0 = LIMAGES + NAT*3*int(IMAGES/2)
              j0 = 0
              do i=1,nat
                  j0 = j0+1
                  do j=1,3
                      j0 = j0+1
                      x(i0) = viacrd(j0)
                      i0 = i0+1
                  enddo
              enddo
          endif
          call DDI_sync(32017)
c
c         !Move the reactant to the center of mass
          i0 = LIMAGES
          if(MASWRK.and.debug) then
              write(iw,9080) i0
          end if
          call PATH_com(iw,nat,anam,bnam,ZMASS,x(i0),MASWRK,debug)
          if(debug) then
              call PATH_chem3d(iw,0,nat,ian,x(i0),TOANGS,MASWRK)
          end if
          call DDI_sync(32018)
c
c         !Move the product to the center of mass
          i0 = LIMAGES +NAT*3*(IMAGES-1)
          if(MASWRK.and.debug) then
              write(iw,9080) i0
          end if
          call PATH_com(iw,nat,anam,bnam,ZMASS,x(i0),MASWRK,debug)
          if(debug) then
              call PATH_chem3d(iw,0,nat,ian,x(i0),TOANGS,MASWRK)
          end if
          call DDI_sync(32019)
c
c         !Move the via point to the center of mass
          if(VIAPNT) then
              i0 = LIMAGES +NAT*3*(IMAGES/2)
              if(MASWRK.and.debug) then
                  write(iw,9080) i0
              end if
              call PATH_com(iw,nat,anam,bnam,ZMASS,x(i0),MASWRK,debug)
              if(debug) then
                  call PATH_chem3d(iw,0,nat,ian,x(i0),TOANGS,MASWRK)
              end if
              call DDI_sync(32020)
          endif
 9080     format(/,'******** Memory pointer =',i15,
     *           /,'Move to the center of mass...')
c
c         !Examine the displacement of each atom...
c         !   Reactant and Product
          i0 = LIMAGES
          i1 = LIMAGES +NAT*3*(IMAGES-1)
          call PATH_dchk(iw,nat,anam,bnam,Zmass,
     &                   x(i0),x(i1),crdtol,MASWRK,DEBUG)
          call DDI_sync(32021)
c
c         !Examine the displacement of each atom...
c         !   Reactant and Via-point
          if(VIAPNT) then
              i0 = LIMAGES
              i2 = LIMAGES +NAT*3*(IMAGES/2)
              call PATH_dchk(iw,nat,anam,bnam,Zmass,
     &                     x(i0),x(i2),crdtol,MASWRK,DEBUG)
              call DDI_sync(32022)
          endif
c
c         !Debug: print out Chem3D input (both the reactant and product)
          if(nat.gt.(mxatm/2)) then
              if(maswrk) then
                  write(iw,'(a)') 'Error in NEBpath: nat*2 > MXATM'
              end if
              call abrt
          endif
          ij = LC1WORK
          i0 = LIMAGES
          i1 = LIMAGES +NAT*3*(IMAGES-1)
          do i=1,nat
              ian(nat+i) = ian(i)
              do j=1,3
                  X(ij) = X(i0)
                  i0 = i0 +1
                  ij = ij +1
              enddo
          enddo
          do i=1,nat
              do j=1,3
                  X(ij) = X(i1)
                  i1 = i1 +1
                  ij = ij +1
              enddo
          enddo
          if(debug) then
              call PATH_chem3d(iw,0,nat*2,ian,x(LC1WORK),TOANGS,MASWRK)
          end if
          call DDI_sync(32023)
c
c
c         !-----------------------------------------------------------------
c         !Rotation of the product molecule around COM...
          if(maswrk) then
              write(iw,'(a)') '*** Coordinate fitting of Structures'
          endif
          if(.not.VIAPNT) then
              i0 = LIMAGES
              i1 = LIMAGES +NAT*3*(IMAGES-1)
              call PATH_anglr(iw,nat,anam,bnam,ian,Zmass,
     &                      X(i0),X(i1),crdtol,
     &                      X(LC1WORK),X(LC2WORK),X(LD1WORK),X(LD2WORK),
     &                      toangs,MASWRK,debug)
          else
              i0 = LIMAGES
              i1 = LIMAGES +NAT*3*(IMAGES/2)
              i2 = LIMAGES +NAT*3*(IMAGES-1)
              call PATH_anglr(iw,nat,anam,bnam,ian,Zmass,
     &                      X(i0),X(i1),crdtol,
     &                      X(LC1WORK),X(LC2WORK),X(LD1WORK),X(LD2WORK),
     &                      toangs,MASWRK,debug)
              call PATH_anglr(iw,nat,anam,bnam,ian,Zmass,
     &                      X(i1),X(i2),crdtol,
     &                      X(LC1WORK),X(LC2WORK),X(LD1WORK),X(LD2WORK),
     &                      toangs,MASWRK,debug)
          endif
          call DDI_sync(32024)
c         !-----------------------------------------------------------------
c
c         !---------------------------------------
c         !Generate the coordinates at each image.
          if(.not.VIAPNT) then
              call PATH_linear_interp(nat*3,nimages,X(LIMAGES))
          else
c             !reactant - via-point
              i1 = LIMAGES +NAT*3*(IMAGES/2)
              nbx = nimages/2 +1
              nby = nimages - nbx +1
              if(maswrk.and.debug) then
                  write(iw,*)
     &                 'Debug: i0,i1,nbx,nby=',i0,i1,nbx,nby
              end if
c
              call PATH_linear_interp(nat*3,nbx,X(LIMAGES))
c
c             !via-point - product
              call PATH_linear_interp(nat*3,nby,X(i1))
          endif
          call DDI_sync(32025)
c
c         !---------------------------------------
c         !Examine the displacement of each atom...
c         !   Reactant and Product
          i1 = LIMAGES -1
          do i=1,nimages
              i0 = i1 +1
              i1 = i1 +NAT*3
              if(maswrk.and.debug) then
                  write(iw,9100) i,i0,i1
              end if
              call PATH_dchk(iw,nat,anam,bnam,Zmass,
     &                     x(i0),x(i1),crdtol,MASWRK,DEBUG)
          enddo
          call DDI_sync(32026)
 9100     format(/,'#image =',i3,'   pointers =',3i15)
c
c         !Debug: print out Chem3D input
          if(debug.and.maswrk) then
              write(iw,'(a)') 'Debug: before IDPP...'
          end if
          i0 = LIMAGES-1
          do n=1,nimages
              if(debug) then
                  call PATH_chem3d(iw,n,nat,ian,x(i0+1),TOANGS,MASWRK)
              end if
              call PATH_chem3d(IPTRAJ,n,nat,ian,x(i0+1),TOANGS,MASWRK)
              do i=1,nat
                  if(maswrk.and.debug) then
                      WRITE(IW,9021) ANAM(I),BNAM(I),
     *                     (x(i0+j),j=1,3),ZMASS(I)
                  end if
                  i0 = i0+3         ! important...
              enddo
          enddo
 9021     FORMAT(1x,a8,a2,1x,F5.1,3F18.10,f15.6,i5) !HARUTA
          if(.not.Morint) then
c.        !SK@20190412
              icycle=0
              call PATH_trajectory(iw,nat,anam,bnam,zan,
     &                   nimages,X(LIMAGES),X(LENGY),X(LGRAD),
     &                X(LVELOC),icycle,maswrk,debug)
              call PATH_trajectory(iptraj,nat,anam,bnam,zan,
     &                   nimages,X(LIMAGES),X(LENGY),X(LGRAD),
     &                X(LVELOC),icycle,maswrk,debug)
              if(maswrk) then
                  write(iw,9112)
              end if
              CALL FLSHBF(IPTRAJ)
              call abrt
          endif
          call DDI_sync(32027)
 9112     FORMAT(//,57('*'),/,57('*'),
     *    /,'**                                                     **',
     *    /,'** Caution: did you examine the molecular orientations **',
     *    /,'** of the reactant and product?  Your coordinates of   **',
     *    /,'** the reactant and product have to be satisfied with  **',
     *    /,'** the following conditions.  Otherwise, the generation**',
     *    /,'** of a realistic path will be failed.                 **',
     *    /,'**                                                     **',
     *    /,'** 1. the atom order should be same.                   **',
     *    /,'** 2. the product should be aligned as closer to the   **',
     *    /,'**    reactant as possible, even though the program    **',
     *    /,'**    will make the reactant and the product moved to  **',
     *    /,'**    the center of mass, respectively, and will erase **',
     *    /,'**    the angular momentum caused by the geometrical   **',
     *    /,'**    displacement.                                    **',
     *    /,'** 3. Please check the orientation of your molecule    **',
     *    /,'**    by using chem3d input printed out into *.trj.    **',
     *    /,'**                                                     **',
     *    /,'** If the above conditions are satisfied, add the      **',
     *    /,'** option "MORINT=.true." and re-submit your job.      **',
     *    /,'**                                    (SK, 2019/02/28) **',
     *    /,'**                                                     **',
     *    /,57('*'),/,57('*'),/)
c
c
c         !------------------
c         !IDPP interpolation
          call PATH_IDPP_interp(iw,nat,nimages,X(LIMAGES),X(LVELOC),
     &             X(LENGY),X(LBFORC), IAN,Zmass,
     &             10.0d0, !crdtol, 
     &             TOANGS,
     &             X(LVWORK),X(LTAU1),X(LTAU2),
     &             X(LC1WORK),X(LC2WORK),X(LD1WORK),X(LD2WORK),
     &             X(LBDIST), 
     &             IPMXCY,!500,!maxcyc, !Can be hardcorded? 1000?
     &             IPDLTT,!0.4d+00, !quickdt for IDPP (DELTAT)
     &             IPSPFC,!0.2d+00, !springforce for IDPP (spforc)
     &             IPOPTL,!0.01d+00,  !tolerance for IDPP (ftol)
     &             maswrk,debug)
!         &         X(LBDIST), maxcyc, DELTAT*5.0d+00,
!         &         SPFORC, Ftol, maswrk,debug)
c---
c    *             X(LBDIST), maxcyc, DELTAT*10.0d+00,
c    *             X(LBDIST), maxcyc, DELTAT*20.0d+00,
c                                       ****************
          call DDI_sync(32028)
c---
c         !x         = X(LIMAGES)  = Coordinates for all images                 (3*NAT*IMAGES)
c         !velo      = X(LVELOC)  = velocity at each image                     (3*NAT*IMAGES)
c         !v         = X(LENGY)   = Total energy at each image                 (IMAGES)
c         !f         = X(LBFORC)  = force at each image                        (3*NAT*IMAGES)
c         !tau       = X(LVWORK)  = Work area of coordinates                  (3*NAT)
c         !tau_plis  = X(LTAU1)   = work area in IDPP                         (3*NAT)
c         !tau_minus = X(LTAU2)   = work area in IDPP                         (3*NAT)
c         !F_T       = X(LC1WORK) = Work area of coordinates for rotation     (3*NAT)
c         !Fs_pa     = X(LC2WORK) = Work area of coordinates for rotation     (3*NAT)
c         !dc        = X(LD1WORK) = Work area of distance matrix for rotation (NAT*NAT)
c         !dd        = X(LD2WORK) = Work area of distance matrix for rotation (NAT*NAT)
c         !di        = X(LBDIST)  = distance matrix at each image              (NAT*NAT*IMAGES)
c
c         !X(LCWORK)  = Work area of coordinates                  (3*NAT)
c         !X(LGRAD)   = RMS gradient at each image                 (IMAGES)
c         !X(LSFORC)  = Spring force constant                     (IMAGES)
c         !X(LDSTNT)  = distance between the images                (IMAGES)
c
c         !Debug: print out Chem3D input
 9200     format(/,'#IMAGE = ',i5)
          IF(MASWRK.and.debug) then
              write(iw,'(a)') 'Debug: after IDPP...'
              i0 = LIMAGES-1
              do n=1,nimages
                  call PATH_chem3d(iw,n,nat,ian,x(i0+1),TOANGS,MASWRK)
                  do i=1,nat
                      WRITE(IW,9021) ANAM(I),BNAM(I),
     *                     (x(i0+j),j=1,3),ZMASS(I)
c                     WRITE(IW,9020) ANAM(I),BNAM(I),ZMASS(I),
c    *                     (x(i0+j),j=1,3)
                      i0 = i0+3
                  enddo
              enddo
          endif
          call DDI_sync(32029)
c
          if(exetyp.eq.check) then
              go to 9999
          end if
c
      !****************************************************
      endif !-- .not.RESTRT
      !****************************************************

c.    !SK@20190314,321...
      RUNTYP = GRADIENT
      call DDI_sync(320131)
c     !------------------------------------------------------------
c     !Energies and gradients at the images obtained by IDPP routine...
      if(maswrk.and.debug) then
          write(iw,'(a)') 'Debug: call PATH_initcalc...'
      end if
      call PATH_initcalc(iw,n3, num, nimages, 0, X(LIMAGES),
     &            X(LENGY), X(LGRAD),X(LBFORC),X(LSTOREI),X(LSTORE),
     &            CRDTOL,TOANGS,TOKCAL,RESTRT,MASWRK,DEBUG)
      call DDI_sync(32030)
c
c     !X(LSTOREI) = Record number of the dictionary file      (IMAGES)
c     !X(LSTORE)  = work area for Coord, Grad, and VEC        (3*NAT +3*NAT +NUM*NUM*2)
c
      call vclr(X(LFTrms),1,nimages)
      call DDI_sync(32031)
c
c     !-----------------------------------------------
c     !-- NEB path optimization
      IF(MASWRK.and.DEBUG) then
          write(iw,'(a,i0)') 'Debug: PATH_main icycle=',(istart+icycle)
      end if
c
c     iswitch = 0   --- qdt = DELTAT*two
c     iswitch = 1   --- qdt = DELTAT
c     iswitch = 2   --- qdt = DELTAT/two
c     iswitch = 3   --- converged.
      iswitch = 0
      !qdt = DELTAT*two
      qdt = DELTAT
c
      do jcycle = 1,MAXCYC !-- NEB MAIN CYCLE
          icycle = istart+jcycle !-- Total cycle
          !IF(MASWRK) then
          !    write(iw,9300) icycle,jcycle,iswitch,qdt
          !    write(ip,9300) icycle,jcycle,iswitch,qdt
          !    write(IPTRAJ,9300) icycle,jcycle,iswitch,qdt
          !endif
          call flshbf(iw)
          call flshbf(ip)
          call flshbf(IPTRAJ)
! 9300 format(//,'*********************',
!     */,'PATH_main cycle# =',i5,' (jcycle,iswitch,qdt=',i5,i3,f10.5,
!     */,'*********************',/)
c
          JFTmax = LFTmax+jcycle-1
c         !------------------------
c
!          if(maswrk) then
!              write(iw,"(/,10X,30(1H-),
!     &             /10X,'Entering PATH_main routine'
!     &             ,/,10X,30(1H-),/)")
!              write(iw,'(a)')''
!          end if
          call PATH_main(IW, n3, NUM, IMAGES, 
     &             X(LSTOREI),X(LSTORE),
     &             icycle, jcycle, MAXCYC,
     &             X(LIMAGES), X(LENGY), X(LBFORC),
     &             NUMHIS,
     &             X(LHISX), X(LHISF),
     &             X(LVELOC), 
     &             X(LGRAD),
     &             FITTNG,
     &             TANGNT, 
!     &             X(LVWORK), X(LTAU1),  X(LTAU2),
     &             FSTEND, LSTEND, DELTAR, SHTHRE,
     &             TSLOCT,
     &             OPTMZR,
     &             QDT, SPFORC,
     &             X(LINVHES),
     &             iswitch,
!     &             X(LC1WORK),X(LC2WORK),
!     &             X(LD1WORK),X(LD2WORK),X(LBDIST),
!     &             X(LFTrms),
!     &             X(jFTmax),
     &             OPTTOL, OPMTOL, CRDTOL, CRMTOL,
     &             UNTCNT, TOANGS, TOKCAL,
     &             abortflag, convflag, DBGLOG, MASWRK, DEBUG)
          call DDI_sync(32032+jcycle)
!          if(maswrk) then
!              write(iw,"(/,10X,30(1H-)/10X,'Exiting PATH_mainroutine',/,
!     &             10X,30(1H-),/)")
!          end if
c
          !-----------------------------------------
c         !Punch out Chem3D input of the current images.
          if(maswrk) then
!              write(iw,9520)icycle,jcycle,nimages,NAT
              write(ip,9520)icycle,jcycle,nimages,NAT
              i0 = LIMAGES-1
              do iimage=1,nimages
!                  call PATH_chem3d(IW,iimage,NAT,IAN,
!     &                             X(i0+1),TOANGS,MASWRK)
                  call PATH_chem3d(IP,iimage,NAT,IAN,
     &                             X(i0+1),TOANGS,MASWRK)
                  i0 = i0 +nat*3
              enddo
              write(ip,9530)icycle,jcycle,nimages,NAT
              ! Continuous file
c             ian --- nat*nimages
              i0 = 0
              do iimage=1,nimages
                  do i=1,NAT
                      i0 = i0+1
                      ix(i0) = ian(i)
                  enddo
              enddo
              call PATH_chem3d(IP,0,NAT*nimages,IX,
     &                         X(LIMAGES),TOANGS,MASWRK)
          end if
 9520 format('*** Chem3D input in cc1 format for a movie',
     *     /,'    (no atom type and connection tables)',
     *  /,'    icycle=',i6,' jcycle=',i6,' nimages=',i6,' natoms=',i6)
 9530 format('*** Chem3D input in cc1 format for an overlap image',
     *     /,'    (no atom type and connection tables)'
     *  /,'    icycle=',i6,' jcycle=',i6,' nimages=',i6,' natoms=',i6)

          call DDI_sync(32033+jcycle)
c         !!Punch out Chemcraft input of the current images.
          !if(maswrk) then
          !    write(iw,'(a)')
     &    !'---- Chemcraft continuous xyz file ---'
          !end if
          !if(maswrk) then
          !    write(iw,'(i0)') nimages*(2+nat)
          !end if
          !i0 = LIMAGES-1
          !do iimage=1,nimages
          !    call PATH_chemcraft(iw,iimage,nat,ian,x(i0+1),
     &    !                        TOANGS,MASWRK)
          !    i0 = i0 +nat*3
          !enddo
          !if(maswrk) then
          !    write(iw,'(a)')
     &    !'---- end of xyz file ---'
          !endif
c
c         !------------------------------------------
          if(abortflag) then !Error while NEB/STR calculation.
              exit !break the NEB/STR loop.
          end if

          if(convflag) then !The path has been converged
              exit !break the NEB/STR loop.
          end if

          !if(jcycle==MAXCYC) then !reached maxcyc
          !    exit !break the NEB/STR loop.
          !end if

c         !------------------------------------------

          call PATH_trajectory(IPTRAJ,nat,anam,bnam,zan,
     *            nimages,X(LIMAGES),X(LENGY),X(LGRAD),
     *            X(LVELOC),icycle,maswrk,debug)
          call DDI_sync(32034+jcycle)
c
          if(iswitch.eq.1) qdt = DELTAT
          if(iswitch.eq.2) qdt = DELTAT/two
          !if(iswitch.eq.3) go to 400!---------------GOTO
          !if(iswitch.eq.3) exit !CONVERGED break do loop
c
      enddo !-- END OF NEB MAIN CYCLE

      call DDI_sync(32035)
      CALL FLSHBF(IPTRAJ)
c
      !------------------------------------------
      !Print out restart data into the .dat file...
 9500 FORMAT(//,57('*'),/,57('*'),
     */,'** For a restarting job, you have to keep your initial **',
     */,'** input deck and append the following data into your  **',
     */,'** input deck.                        (SK, 2019/03/11) **',
     */,57('*'),
     */,' $NEB  IMAGES=',i8,7x,'MAXCYC=',i8,
     */,'       VIAPNT=.',L1,'.',12x,'METHOD=',a8,
     */,'       MOLSYM=.',L1,'.',12x,'MORINT=.T.',
     */,'       RESTRT=.T.',12x,'ISTART=',i8,
     */,'       UNTCRD=',a8,7x,'UNTCNT=',a8,
     */,'       OPTMZR=',a8,7x,'TSLOCT=.',L1,'.',
     */,'       INTERP=',a8,7x,'FITTNG=',a8,
     */,'       FSTEND=',a8,7x,'LSTEND=',a8,
     */,'       DELTAR=',f10.5,5x,'SHTHRE=',i8,
     */,'       TANGNT=',a8,
     */,'       DELTAT=',f10.5,5x,'SPFORC=',f10.5,
     */,'       OPTTOL=',f10.5,5x,'OPMTOL=',f10.5,
     */,'       CRDTOL=',f10.5,5x,'CRMTOL=',f10.5,
     */,' $END')
      if(maswrk.and.UNTCNT=='BOHR') then
!          write(iw,9500) IMAGES,MAXCYC,VIAPNT,METHOD,MOLSYM,
!     *                   (ISTART+icycle),UNTCRD,UNTCNT,
!     *                   OPTMZR,TSLOCT,INTERP,
!     *                   FITTNG,ENDCDN,TANGNT,DELTAT,SPFORC,
!     *                   OPTTOL,OPMTOL,CRDTOL,CRMTOL
          write(ip,9500) IMAGES,MAXCYC,VIAPNT,METHOD,MOLSYM,
     *                   (ISTART+icycle),UNTCRD,UNTCNT,
     *                   OPTMZR,TSLOCT,INTERP,
     *                   FITTNG,FSTEND,LSTEND,DELTAR,SHTHRE,
     *                   TANGNT,DELTAT,SPFORC,
     *                   OPTTOL,OPMTOL,CRDTOL,CRMTOL
      endif
      if(maswrk.and.UNTCNT=='ANGS') then
!          write(iw,9500) IMAGES,MAXCYC,VIAPNT,METHOD,MOLSYM,
!     *                   (ISTART+icycle),UNTCRD,UNTCNT,
!     *                   OPTMZR,TSLOCT,INTERP,
!     *                   FITTNG,ENDCDN,TANGNT,
!     *                   DELTAT/(1/TOANGS *1/sqrt(1/TOKCAL)),
!     *                   SPFORC*TOKCAL/TOANGS/TOANGS,
!     *                   OPTTOL*TOKCAL/TOANGS,OPMTOL*TOKCAL/TOANGS,
!     *                   CRDTOL*TOANGS,CRMTOL*TOANGS
          write(ip,9500) IMAGES,MAXCYC,VIAPNT,METHOD,MOLSYM,
     *                   (ISTART+icycle),UNTCRD,UNTCNT,
     *                   OPTMZR,TSLOCT,INTERP,
     *                   FITTNG,FSTEND,LSTEND,DELTAR,SHTHRE,TANGNT,
     *                   DELTAT/(1/TOANGS *1/sqrt(1/TOKCAL)),
     *                   SPFORC*TOKCAL/TOANGS/TOANGS,
     *                   OPTTOL*TOKCAL/TOANGS,OPMTOL*TOKCAL/TOANGS,
     *                   CRDTOL*TOANGS,CRMTOL*TOANGS
      endif


      call DDI_sync(32038)
c
c     !$IMAGESX   coordinates & energies (all in atomic unit)
      if(maswrk) then
!          call PATH_trajectory(iw,nat,anam,bnam,zan,
!     *               nimages,X(LIMAGES),X(LENGY),X(LGRAD),
!     *            X(LVELOC),icycle,maswrk,debug)
          call PATH_trajectory(ip,nat,anam,bnam,zan,
     *               nimages,X(LIMAGES),X(LENGY),X(LGRAD),
     *            X(LVELOC),icycle,maswrk,debug)
      endif

      !Out Final Data to log file
      if(maswrk) then
          call PATH_finalresult(iw,nat,anam,bnam,zan,
     *               nimages,X(LIMAGES),X(LENGY),X(LGRAD),
     *            X(LVELOC),icycle,maswrk,debug)
      endif


      call DDI_sync(32039)
c
!DELETEc     !-----------------------------------------
!DELETEc     !Punch out Chem3D input of the final cycle.
!DELETE      if(maswrk) then
!DELETE          write(iw,9520)icycle,jcycle,nimages,NAT
!DELETE          write(ip,9520)icycle,jcycle,nimages,NAT
!DELETE          i0 = LIMAGES-1
!DELETE          do iimage=1,nimages
!DELETE              call PATH_chem3d(IW,iimage,NAT,IAN,X(i0+1),TOANGS,MASWRK)
!DELETE              call PATH_chem3d(IP,iimage,NAT,IAN,X(i0+1),TOANGS,MASWRK)
!DELETE              i0 = i0 +NAT*3
!DELETE          enddo
!DELETE          write(ip,9530)icycle,jcycle,nimages,NAT
!DELETEc         ian --- nat*nimages
!DELETE          i0 = 0
!DELETE          do iimage=1,nimages
!DELETE              do i=1,NAT
!DELETE                  i0 = i0+1
!DELETE                  ix(i0) = ian(i)
!DELETE              enddo
!DELETE          enddo
!DELETE          call PATH_chem3d(IP,0,NAT*nimages,IX,X(LIMAGES),TOANGS,MASWRK)
!DELETE      endif
!DELETE      call DDI_sync(32040)
c
!DELETEc     !-----------------------------------------
!DELETEc     !Punch out ChemCraft input of the final cycle.
!DELETE      if(maswrk) then
!DELETE          write(iw,9521)
!DELETE          write(ip,9521)
!DELETE          i0 = LIMAGES-1
!DELETE          do iimage=1,nimages
!DELETE              call PATH_chemcraft(iw,iimage,nat,ian,x(i0+1),
!DELETE     &                            TOANGS,MASWRK)
!DELETE              call PATH_chemcraft(ip,iimage,nat,ian,x(i0+1),
!DELETE     &                            TOANGS,MASWRK)
!DELETE              i0 = i0 +nat*3
!DELETE          enddo
!DELETE      endif
!DELETE 9521 format('*** ChemCraft input in xyz format')
c
      !-----------------------------------------
      ! in case of SCF convergence failure
      if (abortflag) then
          if (maswrk) then
              write(iw,'(3(a,/))')'ERROR: failure to converge SCF.',
     &                       '       The structure may be broken.',
     &                       '       ALL CALCULATION will be aborted.'
          end if
          call abrt
      end if

      !-----------------------------------------
      ! Number of steps exceeded
      if (.not.convflag.and.maswrk) then
          write(iw,"(//,10x,43('*'),
     &        /,10x,'** Path optimization cycle has run       **',
     &        /,10x,'** but reaction path was NOT CONVERGED.  **',
     &        /,10x,'** Check resultant structure and data.   **',
     &        /,10x,'** More cycles may be needed.            **',
     &        /,10x,'** If so, restart your calculation       **',
     &        /,10x,'** with restart option.                  **',
     &        /,10x,43('*'))")
      end if

 9999 CONTINUE !if(exetyp.eq.check) go to 9999
      CALL RETFM(NEED)
      CALL TIMIT(1)
      RETURN
      END SUBROUTINE NEBPX

!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------

C*MODULE NEBPATH *DECK PATH_initcalc
C>
C>    @brief    NEBPATH: first energy and gradient calculation at each image
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_initcalc(iw,n3, L1, nimages, icycle, X, V, 
     *               G_RMS, F,
     *               irec, STORE, crdtol, toangs, TOKCAL,
     *               restrt,maswrk,debug)
      implicit none
c
      integer, intent(in) :: iw, n3, L1, nimages, icycle
      double precision, intent(in) :: X(1:n3,1:nimages)
      double precision, intent(inout) :: V(1:nimages)
      double precision, intent(inout) :: G_RMS(1:nimages)
      double precision, intent(out) :: F(1:n3,1:nimages)
      integer, intent(out) :: irec(1:nimages)
      double precision, intent(out) :: STORE(1:6*NAT+L1*L1*2)
c     X(LSTOREI) = Record number of the dictionary file      (IMAGES)
c     X(LSTORE)  = work area for Coord, Grad, and VEC        (3*NAT +3*NAT +NUM*NUM*2)
c
      double precision, intent(in) :: CRDTOL, TOANGS, TOKCAL
      logical, intent(in) :: RESTRT
      logical :: maswrk, debug

      integer :: i, i0, is, ie, j, j0
      integer :: iimage
      integer :: nnode, mynode
      double precision :: ediff

      double precision :: NEB_unit_vec, PATH_dot_prod
      double precision :: NEB_euclid_norm
      double precision :: PATH_RMS

      integer :: L3, nstore, n3x2, istoreb
c
      double precision, parameter :: ZERO=0.00D+00
      double precision, parameter :: ONE=1.00D+00
      double precision, parameter :: TWO=2.00d+00
c 
      integer, parameter :: MXATM=2000, MXA3=3*MXATM, MXAO=8192

      double precision :: ZMASS
      COMMON /MASSES/ ZMASS(MXATM)
c
c     COMMON /FUNCT / E,EG(MXA3)
c     COMMON /FUNCT / ENERGY,EGRAD(3,MXATM)
      double precision :: ENERGY, EGRAD
      COMMON /FUNCT / ENERGY,EGRAD(MXA3)
c     COMMON /GRAD  / DE(3,MXATM)
      double precision :: DE
      COMMON /GRAD  / DE(MXA3)
c
      integer :: NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      double precision :: ZAN,C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      double precision :: TITLE,ANAM,BNAM,BFLAB
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      double precision :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      integer :: MPLEVL,MPCTYP
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      double precision :: RUNTYP,EXETYP
      integer :: NEVALS,NGLEVL,NHLEVL
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
c
      integer :: idummy, IDAF,NAV,IODA
c     COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /IOFILE/ idummy(5),IDAF,NAV,IODA(950)
c
c     COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      integer :: NPRINT,jdummy
      COMMON /OUTPUT/ NPRINT,jdummy(5)
c
      double precision :: SCFUHF
      double precision :: CIGUGA
c     character*8  SCFTYP,CITYP
      data SCFUHF/8HUHF     /
      data CIGUGA/8HGUGA    /

      double precision :: TIMLIM
      integer :: IREST,kdummy
c     COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RESTAR/ TIMLIM,IREST,kdummy(6)
c
      integer :: ME,MASTER,NPROC,IBTYP,IPTIM
      logical :: GOPARR,DSKWRK,MASWRKx
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRKx
      double precision :: OSPT,CODEMP,SCSPT,TOL
      integer :: METHOD,NWDMP2,MEMPRI,MPPROP
      integer :: NACORE,NBCORE,NOA,NOB,NORB,NBF,NOMIT,MOCPHF,MAXITC
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NORB,NBF,NOMIT,MOCPHF,MAXITC
c
      ! n3        : n3 = 3 * the number of atoms
      ! nimages    : the number of images
      ! X         : Coordinates of atoms in all images
      ! V         : Energies of all images
      ! G_RMS      : RMS gradients of all images
      ! spring    : spring constant
c
c
      call DDI_sync(320130)
!      IF(MASWRK) WRITE(IW,9000)
! 9000 FORMAT(/,10X,30(1H-)/10X,'Entering PATH_initcalc routine',/,
!     *         10X,30(1H-),/)
c
c     L1 = NUM
      L3 = NUM*NUM
      nstore = (n3 + L3)*2
      n3x2 = n3*2
      istoreb = n3x2 + L3 +1
c
c     Record number for the dictionary file...
      do i=1,nimages
         irec(i) = 700+i
         enddo
      if(maswrk.and.debug) then
         write(iw,'(a,5i8)') 'Debug: L1,L3,n3x2,istoreb,nstore =',
     *                        L1,L3,n3x2,istoreb,nstore
         write(iw,'(10i5)') iRec(1:nimages)
         endif
c
c     Clear arrays...
      if(.not.restrt) then
         V(1:nimages) = zero
         G_RMS(1:nimages) = zero
         endif
c
c     For parallelization
      if(maswrk) then
         !write(iw,'(a,L1)') 'Debug in PATH_initcalc: goparr =',goparr
         call ddi_nnode(nnode,mynode)
         !if(goparr) write(iw,'(a,3i5)') 'Debug: nproc,nnode,mynode=',
     *   !           nproc,nnode,mynode
      endif
c.SK@20190315 ----------------
c
c     **********************************************
c     In order to generate the consistent orbitals
c     at each image, single point calculations are
c     performed sequentially from the first image
c     to the last image.
c     Caution: the geometry at the last image was
c     rotated for zero angular momentum caused by
c     the geometrical displacement between the first
c     and last images.
c
c     It is necessary to generate $VEC at each image squentially,
c     and to store them into the dictionary file.
c
c        V(iimage)        = energies
c        F(1:n3,1:iimage) = gradients
c        G_RMS(iimage)     = gradient RMS
c
c     *******************************
c     Energy & Gradients at each image.
      do iimage=1,nimages
          if(maswrk) then
              write(iw,'(//,18("-"),x,a,i5,x,18("-"))')
     &       'ENERGY and GRADIENT calculation (initial run) #IMAGE=',
     &       iimage
          end if
c         if((iimage.gt.1).and.(.not.debug)) NPRINT =-5
c         if(debug) NPRINT =5
          !if(debug) then
          !    !NPRINT =5
          !    NPRINT =-5
          !else
          !    !if(iimage.gt.1) NPRINT =-5
          !    NPRINT =-5
          !endif
          NPRINT =5
c                       NPRINT =-5      ! minimal
c                       NPRINT = 3      ! 1e
c                       NPRINT = 5      ! scf
c                       NPRINT = 7      ! normal
c                       NPRINT = 9      ! maximum
c

c          !Load the information of the current image...
          j0 = 0
          do i=1,nat
              do j=1,3
                  j0 = j0 +1
                  c(j,i) = x(j0,iimage)
              enddo
          enddo
          store(1:nstore) = zero
          ENERGY = zero
          EGRAD(1:n3) = zero
c

          if(maswrk) then
              write(iw,'(/a,i5)')
     &             '*** Coordinate [bohr] of #IMAGE=',iimage
              !write(iw,'(a,6i5)')'Debug: NAT,n3,NUM,L1,L3,NE=',
     &        !     NAT,n3,NUM,L1,L3,NE
              do i=1,nat
                  write(iw,'(1x,a8,a2,1x,F5.1,3F18.10)') 
     &                 ANAM(i),BNAM(i),ZAN(i),(C(j,i),j=1,3)
     &            !     ,ZMASS(i),IAN(i)
              enddo
          endif
          call DDI_sync(320132+iimage)

          if(maswrk) then
              write(iw,'(/a/)')
     *       '*** START A SINGLE POINT CALCULATION ***'
          end if
          CALL ENERGX
c         ***********
          call DDI_sync(320133+iimage)
c
          if(ENERGY.eq.ZERO) then
              if(maswrk) then
                  write(iw,'(a)')
     &                 'ERROR: failed to obtain a total energy...'
                  write(iw,'(a)')'The structure may be broken.'
                  write(iw,'(a)')'ALL CALCULATION will be aborted.'
              end if
              call abrt
          endif
          call DDI_sync(320134+iimage)

c

          if(restrt) then
              if(v(iimage).eq.zero) then
c                This image is newly added...
                  V(iimage)=Energy
              else
                  ediff = abs(energy-v(iimage))
                  if(ediff.gt.0.00001d+00) then
c                               12345
                      if(maswrk) then
                          write(iw,9032) iimage,v(iimage),energy
                      end if
                      call abrt
                  endif
              endif
          endif
 9032 format(/,'Error: the energy difference at the image#',i3,
     *         ' too large: Energy =',2f20.10)
c
c                                    ----------------------------
          if(maswrk) then
              write(iw,'(/a/)') '*** START A GRADIENT CALCULATION ***'
          end if
          call DDI_sync(320135+iimage)
c
          IF (CITYP.EQ.CIGUGA) then
              CALL CIGRAD
              ELSE
              CALL HFGRAD
              END IF
          call DDI_sync(320136+iimage)
c
c         ------------------------------------------
c         Store the data into the dictionary file...
c         (iimage, Energy) C, EGRAD, VEC(alpha&beta)
c
          do i=1,n3
             STORE(i) = x(i,iimage)
             STORE(n3+i) =-EGRAD(i)
          enddo
          i0 = n3*2
c
c         alpha orbitals...
          call DAREAD(IDAF,IODA,STORE(i0+1),L3,15,0)
          if(maswrk) then
              write(iw,'(a,i5)')
     &       'Read the alpha orbitals at #IMAGE=',iimage
          end if
c         debug print...
c         CALL PUSQL(STORE(i0+1),iw,L1,L1)
c
c         beta orbitals, if necessary
          IF(SCFTYP.EQ.SCFUHF) THEN
              call DAREAD(IDAF,IODA,STORE(i0+istoreb),L3,19,0)
              if(maswrk) then
                  write(iw,'(a,i5)')
     &           'Read the beta orbitals at #IMAGE=',iimage
              end if
          endif
!          call DDI_sync(320137+iimage)
c
c         double precision :: STORE(6*NAT+NUM*NUM*2)
c         double precision :: STORE(2*N3+L3*2)
          call DAWRIT(IDAF,IODA,STORE,nstore,iREC(iimage),0)
c         ---------------------------------------------- floating point
          if(maswrk) write(iw,9050) iREC(iimage),iimage,idaf
 9050 format(/,'*** Store the coordinates, gradients, and',
     &' vectors into the dictionary file.  iREC=',3i5)
c
          V(iimage)      = ENERGY
          F(1:n3,iimage) = -EGRAD(1:n3)
          G_RMS(iimage)   = PATH_RMS(n3,EGRAD(1:n3))
c

          if(maswrk) then
              write(iw,'(/2a,i5)')
     &             '*** Energy [hartree] and ',
     &             'Gradient [hartree/bohr] of #IMAGE=',iimage
              write(iw,'(a,f20.10,6x,a,f20.10)')
     &             'Energy =',V(iimage),'G_RMS =',G_RMS(iimage)
              ie = 0
              do i=1,nat
                  is=ie+1
                  ie=ie+3
                  write(iw,'(a,i5,2x,a8,a2,a,3f20.10)')
     &                 '#atom',i,ANAM(i),BNAM(i),'EGRAD = ',
     &                 (EGRAD(j),j=is,ie)
              enddo
          endif

          call DDI_sync(320138+iimage)
c
          enddo
c
      !-- Data table and covergence check table
!      call PATH_summary(iw,NAT,nimages,ZMASS,X,V,
!     &               icycle,1,0,
!     &               0.0d0,0.0d0,0.0d0,0.0d0,0.0d0,
!     &               0.0d0,0.0d0,0.0d0,
!     &               0.0d0,0.0d0,0.0d0,0.0d0,.false.,.false.,
!     &               'ANGS',TOANGS,TOKCAL,MASWRK,DEBUG)
!      call PATH_summary(iw,NAT,nimages,ZMASS,X,V,
!     &               icycle,jcycle,i_CI,
!     &               G_RMS,F_RMS,F_perp_RMS,F_para_RMS,Fs_para_RMS,
!     &               F_MAX,D_MAX,D_RMS,
!     &               OPMTOL,OPTTOL,CRMTOL,CRDTOL,conv,convflag,
!     &               UNTCNT,TOANGS,TOKCAL,MASWRK,DEBUG)



c
!      if(maswrk) then
!          write(iw,"(/,10X,30(1H-)/10X,'Exiting PATH_initcalc routine',
!     &    /,10X,30(1H-),/)")
!      end if
      call DDI_sync(320139)
      end subroutine PATH_initcalc






C*MODULE NEBPATH *DECK PATH_main
C>
C>    @brief    NEBPATH: Optimization of geometry at each image
C>                       in order that the energy gradient perpendicular
C>                       to the reaction path becomes zero.
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_main(iw, n3, L1, nimages,
     &           irec, store,
     &           icycle, jcycle, MAXCYC,
     &           X, V, F, 
     &           NUMHIS,
     &           HisX, HisF,
     &           velo,
     &           G_RMS,
     &           FITTNG, 
     &           TANGNT, 
!     &           tau, tau_plus, tau_minus, 
     &           FSTEND, LSTEND, DELTAR, SHTHRE,
     &           TSLOCT,
     &           OPTMZR, 
     &           QuickDT, spring,
     &           InvHess,
     &           iswitch,
!     &           F_T, Fs_pa,
!     &           dc,dd,di, 
!     &           F_Trms,
!     &           FTmax,
     &           OPTTOL, OPMTOL, CRDTOL, CRMTOL,
     &           UNTCNT, TOANGS, TOKCAL,
     &           abortflag, convflag, DBGLOG, MASWRK, DEBUG)
c     NUM = number of CARTESIAN GAUSSIAN BASIS FUNCTIONS
      !IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      implicit none
      integer, intent(in) :: iw, n3, L1, nimages
      integer, intent(in) :: irec(1:nimages)
      double precision, intent(out) :: store(n3*2+L1*L1*2)
      integer, intent(in) :: icycle, jcycle, MAXCYC
      double precision, intent(inout) :: X(1:n3,1:nimages)
      double precision, intent(inout) :: V(1:nimages)
      double precision, intent(out) :: F(1:n3,1:nimages)
      integer, intent(in) :: NUMHIS
      double precision, intent(inout) :: HisX(1:n3,1:nimages,1:numHis)
      double precision, intent(inout) :: HisF(1:n3,1:nimages,1:numHis)
      double precision, intent(inout) :: velo(1:n3,1:nimages)
      double precision, intent(inout) :: G_RMS(1:nimages)
      double precision, intent(in) :: FITTNG, FSTEND, LSTEND, DELTAR
      integer, intent(in) :: SHTHRE
      double precision, intent(in) :: TANGNT
      !double precision, intent(out) :: tau(1:n3)
      !double precision, intent(out) :: tau_plus(1:n3), tau_minus(1:n3)
      logical, intent(in) :: TSLOCT
      double precision, intent(in) :: OPTMZR
      double precision, intent(in) :: quickdt, spring
      double precision, intent(inout) :: 
     &                  InvHess(1:nimages,1:n3,1:nimages,1:n3)
      integer, intent(inout) :: iswitch
      double precision, intent(in) :: OPMTOL,OPTTOL,CRMTOL,CRDTOL
      double precision, intent(in) :: UNTCNT, TOANGS, TOKCAL
      logical, intent(inout) :: abortflag
      logical, intent(inout) :: convflag
      logical, intent(in) :: DBGLOG
      logical, intent(in) :: MASWRK
      logical, intent(inout) :: DEBUG

      double precision :: tau(1:n3)
      double precision :: tau_plus(1:n3), tau_minus(1:n3)
      !double precision, intent(out) :: F_perp(1:n3), Fs_para(1:n3)
      double precision :: F_perp(1:n3), Fs_para(1:n3)
      !double precision, intent(in) :: dc(1:n3/3,1:n3/3)
      double precision :: dc(1:n3/3,1:n3/3)
      !double precision, intent(in) :: dd(1:n3/3,1:n3/3)
      double precision :: dd(1:n3/3,1:n3/3)
      !double precision, intent(in) :: di(1:n3,1:nimages)
      !double precision :: F_Trms(1:nimages)
      !double precision, intent(out) :: F_Trms(1:nimages)


      double precision :: F_perp_RMS(1:nimages)
      double precision :: F_para_RMS(1:nimages)
      double precision :: Fs_para_RMS(1:nimages)

      !double precision :: FTmax
      !double precision, intent(out) :: FTmax

      double precision :: F_para(1:n3)
      integer :: i, j, k, j0
      integer :: iimage ,ie,is

      !double precision :: fperp, fpara
      integer :: ichk, jchk 

      double precision :: NEB_unit_vec
      double precision :: NEB_euclid_norm
      double precision :: PATH_dot_prod
      double precision :: PATH_euclid_norm
      double precision :: PATH_RMS


      !-- E&G calc image
      integer :: calc_first, calc_last

      !-- Climbing Image
      double precision :: V_CI
      integer :: i_CI

      integer :: threshold1
      integer :: threshold2
      double precision :: displimit


      double precision :: dr, dr_incr

      !Convergence check
      double precision :: F_MAX(0:nimages)! (0) is maximum of all
      double precision :: F_RMS(0:nimages)! (0) is maximum of all
      double precision :: D_MAX(0:nimages)! (0) is maximum of all
      double precision :: D_RMS(0:nimages)! (0) is maximum of all
      logical :: conv(1:4)

      integer :: L3, nstore, n3x2, istoreb

      double precision, parameter :: ZERO=0.00D+00
      double precision, parameter :: ONE=1.00D+00
      double precision, parameter :: TWO=2.00d+00
   
      integer, parameter :: MXATM=2000, MXA3=3*MXATM, MXAO=8192

      double precision :: ZMASS
      COMMON /MASSES/ ZMASS(MXATM)
      double precision :: ENERGY, EGRAD
      COMMON /FUNCT / ENERGY,EGRAD(MXA3)
c
      integer :: NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      double precision :: ZAN,C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      double precision :: TITLE,ANAM,BNAM,BFLAB
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      double precision :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP
      integer :: MPLEVL,MPCTYP
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
c
      integer :: idummy, IDAF,NAV,IODA
      COMMON /IOFILE/ idummy(5),IDAF,NAV,IODA(950)
c
      integer :: NPRINT,jdummy
      COMMON /OUTPUT/ NPRINT,jdummy(5)
c
      double precision :: SCFUHF
      double precision :: CIGUGA
      data SCFUHF/8HUHF     /
      data CIGUGA/8HGUGA    /
c
      ! n3        : n3 = 3 * the number of atoms
      ! nimages    : the number of images
      ! X         : Coordinates of atoms in all images
      ! velo      : velocity for using quick-min optimizer
      ! V         : Energies of all images
      ! G_RMS      : RMS gradients of all images
      ! spring  : spring constant
      ! tau       : tangent vector to the path
      ! tau_plus  : forward difference
      ! tau_minus : backward difference
      ! F         : force on atoms (negative gradient)
      ! F_perp     : force in the direction perpendicular to the tangent vector
      ! F_para       : force in the direction parallel to the tangent vector
      ! Fs_para     : spring force in the direction parallel to the tangent vector
c
c     L1 = NUM
      L3 = NUM*NUM
      nstore = (n3 + L3)*2
      n3x2 = n3*2
      istoreb = n3x2 + L3 +1
c
      call DDI_sync(320150)

      !Moving up history
      call PATH_moveup_history(iw,n3,nimages,numHis,X,HisX,F,HisF,
     &maswrk,debug)

      if(maswrk.and.debug) then
          write(iw,'(a)')'IMAGES,L1,NUM,L3,nstore,istoreb,n3x2,n3'
          write(iw,'(8i8)') nimages,L1,NUM,L3,nstore,istoreb,n3x2,n3
      endif

      call DDI_sync(320151)

      if (maswrk) then
          write(iw,'(a)') ''
      end if
      !------------------------------------------
      ! -- Climbing image finding
      i_CI = 0
      if (TSLOCT) then
           if (maswrk) then
               write(iw,'(a)') '-- Climbing Image --'
           end if
           V_CI = V(1)
           i_CI = 1
           do iimage = 2, nimages
               if (maswrk.and.debug) then
                   write(iw,'(a,i4,a,f20.13,a)')
     &                  'CI: IMAGE ',iimage,' = ',V(iimage),' [hartree]'
               end if
               if ( V(iimage) > V_CI ) then
                   V_CI = V(iimage)
                   i_CI = iimage
               end if
           end do
           if ( i_CI==1 ) then
               if (maswrk) then
                   write(iw,'(a)')
     &                  'CI: First end image has highest energy.'
                   write(iw,'(4x,a)')'#Image=2 will be regarded as CI.'
               end if
               i_CI=2
           else if ( i_CI==nimages ) then
               if (maswrk) then
                   write(iw,'(a)')
     &                  'CI: Last end image has highest energy.'
                   write(iw,'(4x,a,i0,a)')
     &             '#Image=',nimages-1,' will be regarded as CI.'
               end if
               i_CI=nimages-1
           end if
           if (maswrk) then
               write(iw,'(a,i4,a,a,f20.13,a,/)')
     &              'CI: image ',i_CI,' is now climbing image. ',
     &              'E=',V_CI,' [hartree]'
           end if
      end if

      !------------------------------------------
      !-- Initialize Variables.
      F_RMS(1:nimages) = 0.0d0
      F_perp_RMS(1:nimages) = 0.0d0
      F_para_RMS(1:nimages) = 0.0d0
      Fs_para_RMS(1:nimages) = 0.0d0
      call DDI_sync(3201599)

      !------------------------------------------
      !-- First end images conditions
      !   Optimizing forces are calculated here.
      !if(MASWRK) then
      !    write(iw,'(a)') '-- FIRST END CONDITION --'
      !    write(iw,'(2a)')'FSTEND=',FSTEND
      !end if
      if(FSTEND=='OPTIMIZE') then
          continue
      else if(FSTEND=='FIXED') then
          F(1:n3,1) = 0.0d0
      else if(FSTEND=='FREE') then
          tau_plus(1:n3) = X(1:n3,2) - X(1:n3,1)
          tau(1:n3) = tau_plus(1:n3)
          call PATH_unit_vec(n3,tau(1:n3))
          F_perp(1:n3) = F(1:n3,1)
     &         -PATH_dot_prod(n3,F(1:n3,1),tau(1:n3))*tau(1:n3)
          F_perp_RMS(1) = PATH_RMS(n3,F_perp(1:n3))
          F(1:n3,1) = F_perp(1:n3)
      else if(FSTEND=='ADAPTIVE') then
          if(DELTAR==0.0d0) then !dr defined as averaged distance
              if(jcycle-1 == 1) then ! First cycle
!DELETE                  dr = PATH_totlength(n3,nimages,X(1:n3,1:nimages))
!DELETE     &                 /(nimages - 1)
                  !dr = 0.0d0
                  call PATH_avelength(n3,nimages,X(1:n3,1:nimages),dr)
              end if
          else ! dr will become DELTAR
              if(jcycle-1 == 1) then ! First cycle
!                  dr = PATH_totlength(n3,nimages,X(1:n3,1:nimages))
!     &                 /(nimages - 1)
                  call PATH_avelength(n3,nimages,X(1:n3,1:nimages),dr)
                  if(SHTHRE == 1) then ! dr is DELTAR from the beginning
                      dr = DELTAR
                  else ! dr will be gradually changed to DELTAR
                      if(dr > DELTAR) then
                          dr_incr = (dr-DELTAR)/dble(SHTHRE-1)
                      else
                          dr_incr = (DELTAR-dr)/dble(SHTHRE-1)
                      end if
                  end if
              else if(jcycle-1 < SHTHRE) then ! dr will be changing
                  if(dr > DELTAR) then
                      dr = dr - dr_incr
                  else
                      dr = dr + dr_incr
                  end if
              else if(jcycle-1 == SHTHRE) then ! Finally dr will be DELTAR
                  dr = DELTAR
              end if
          end if
          tau_plus(1:n3) = X(1:n3,2) - X(1:n3,1)
          tau(1:n3) = tau_plus(1:n3)
          call PATH_unit_vec(n3,tau(1:n3))
          F_perp(1:n3) = F(1:n3,1)
     &         -PATH_dot_prod(n3,F(1:n3,1),tau(1:n3))*tau(1:n3)
          F_perp_RMS(1) = PATH_RMS(n3,F_perp(1:n3))
          Fs_para(1:n3) = spring
     &         *(PATH_euclid_norm(n3, tau_plus(1:n3)) - dr)*tau(1:n3)
          Fs_para_RMS(1) = PATH_RMS(n3,Fs_para(1:n3))
          F(1:n3,1) = F_perp(1:n3) + Fs_para(1:n3)
          if(MASWRK) then
              write(iw,'(a)')'Adaptive-end first image'
              write(iw,'(a,f20.10,a)')
     &             '(1) Length of between image 1 and 2:',
     &             PATH_euclid_norm(n3,tau_plus(1:n3)),' [Bohr]'
              write(iw,'(a,f20.10)')
     &             '(2)                 Set length (dr):',dr
              write(iw,'(a,f20.10)')
     &             '                          (1) - (2):',
     &             PATH_euclid_norm(n3,tau_plus(1:n3))-dr
              if(PATH_euclid_norm(n3,tau_plus(1:n3))-dr > 0.0d0) then
                  write(iw,'(a)')'First image will reduce its length'
              else
                  write(iw,'(a)')'First image will increase its length'
              end if
          end if
      else
          if(MASWRK) then
              write(iw,'(3a)')'FSTEND=',FSTEND,'is not supported.'
          end if
          call abrt
      end if

      !------------------------------------------
      !-- Last end images conditions
      !   Optimizing forces are calculated here.
      !if(MASWRK) then
      !    write(iw,'(a)') '-- LAST END CONDITION --'
      !    write(iw,'(2a)')'LSTEND=',LSTEND
      !end if
      if(LSTEND=='OPTIMIZE') then
          continue
      else if(LSTEND=='FIXED') then
          F(1:n3,nimages) = 0.0d0
      else if(LSTEND=='FREE') then
          tau_minus(1:n3) = X(1:n3,nimages) - X(1:n3,nimages-1)
          tau(1:n3) = tau_minus(1:n3)
          call PATH_unit_vec(n3,tau(1:n3))
          F_perp(1:n3) = F(1:n3,nimages)
     &         -PATH_dot_prod(n3,F(1:n3,nimages),tau(1:n3))*tau(1:n3)
          F_perp_RMS(nimages) = PATH_RMS(n3,F_perp(1:n3))
          F(1:n3,nimages) = F_perp(1:n3)
      else if(LSTEND=='ADAPTIVE') then
          if(FSTEND/='ADAPTIVE') then ! Skip same procedure
              if(DELTAR==0.0d0) then !dr defined as averaged distance
                  if(jcycle-1 == 1) then ! First cycle
!                      dr = PATH_totlength(n3,nimages,X(1:n3,1:nimages))
!     &                     /(nimages - 1)
                      call PATH_avelength(n3,nimages,
     &                                    X(1:n3,1:nimages),dr)
                  end if
              else ! dr will become DELTAR
                  if(jcycle-1 == 1) then ! First cycle
!                      dr = PATH_totlength(n3,nimages,X(1:n3,1:nimages))
!     &                     /(nimages - 1)
                      call PATH_avelength(n3,nimages,
     &                                    X(1:n3,1:nimages),dr)
                      if(SHTHRE == 1) then ! dr is DELTAR from the beginning
                          dr = DELTAR
                      else ! dr will be gradually changed to DELTAR
                          if(dr > DELTAR) then
                              dr_incr = (dr-DELTAR)/dble(SHTHRE-1)
                          else
                              dr_incr = (DELTAR-dr)/dble(SHTHRE-1)
                          end if
                      end if
                  else if(jcycle-1 < SHTHRE) then ! dr will be changing
                      if(dr > DELTAR) then
                          dr = dr - dr_incr
                      else
                          dr = dr + dr_incr
                      end if
                  else if(jcycle-1 == SHTHRE) then ! Finally dr will be DELTAR
                      dr = DELTAR
                  end if
              end if
          end if
          tau_minus(1:n3) = X(1:n3,nimages) - X(1:n3,nimages-1)
          tau(1:n3) = tau_minus(1:n3)
          call PATH_unit_vec(n3,tau(1:n3))
          F_perp(1:n3) = F(1:n3,nimages)
     &         -PATH_dot_prod(n3,F(1:n3,nimages),tau(1:n3))*tau(1:n3)
          F_perp_RMS(nimages) = PATH_RMS(n3,F_perp(1:n3))
          Fs_para(1:n3) = spring
     &         *(dr - PATH_euclid_norm(n3, tau_minus(1:n3)))*tau(1:n3)
          Fs_para_RMS(nimages) = PATH_RMS(n3,Fs_para(1:n3))
          F(1:n3,nimages) = F_perp(1:n3) + Fs_para(1:n3)
          if(MASWRK) then
              write(iw,'(a)')'Adaptive-end last image'
              write(iw,'(a,f20.10,a)')
     &             '(1) Length of between image n-1 and n:',
     &             PATH_euclid_norm(n3,tau_minus(1:n3)),' [Bohr]'
              write(iw,'(a,f20.10)')
     &             '(2)                   Set length (dr):',dr
              write(iw,'(a,f20.10)')
     &             '                           (1) - (2) :',
     &             PATH_euclid_norm(n3,tau_minus(1:n3))-dr
              if(PATH_euclid_norm(n3,tau_minus(1:n3))-dr > 0.0d0) then
                  write(iw,'(a)')'Last image will reduce its length'
              else
                  write(iw,'(a)')'Last image will increase its length'
              end if
          end if
      else
          if(MASWRK) then
              write(iw,'(3a)')'LSTEND=',LSTEND,'is not supported.'
          end if
          call abrt
      end if

      !------------------------------------------
      !-- Intermediate images conditions
      !   Neb forces are calculated here.
      !   Forces of end images(1st and last images) are not modified.
      do iimage = 2, nimages-1
          if(maswrk.and.debug) then
              write(iw,'(a,i0)') 'Debug: iimage= ',iimage
          end if
c
          ! Calculation of tangent vectors along the path
          tau_plus(1:n3)  = X(1:n3,iimage+1) - X(1:n3,iimage)
          tau_minus(1:n3) = X(1:n3,iimage)   - X(1:n3,iimage-1)
          tau(1:n3) = tau_plus(1:n3) + tau_minus(1:n3)
          call PATH_unit_vec2(n3,tau(1:n3))
c
          ! Calculation of perpendicular forces
          ! These forces are perpendicular to the tangent vectors.
          F_perp(1:n3) = F(1:n3,iimage)
     &         -PATH_dot_prod(n3,F(1:n3,iimage),tau(1:n3))*tau(1:n3)
c
          ! Calculation of parallel forces
          ! These forces are parallel to the tangent vectors.
          ! This is used for CI Force
          F_para(1:n3) = 
     &         PATH_dot_prod(n3,F(1:n3,iimage),tau(1:n3))*tau(1:n3)
c
          ! Calculation of spring forces
          ! These forces are parallel to the tangent vectors.
          Fs_para(1:n3) = tau_plus(1:n3) - tau_minus(1:n3)
          Fs_para(1:n3) = spring
     *         *PATH_dot_prod(n3,Fs_para(1:n3),tau(1:n3)) *tau(1:n3)
c
          ! Calclation of resultant forces (NEB forces)
          ! Force values are overwritten here.
          if (TSLOCT) then ! Climbing image
              if (iimage == i_CI ) then
                  F(1:n3,iimage) = F_perp(1:n3) - F_para(1:n3)
              else
                  F(1:n3,iimage) = F_perp(1:n3) + Fs_para(1:n3)
              end if
          else
              F(1:n3,iimage) = F_perp(1:n3) + Fs_para(1:n3)
          end if

          ! RMS Calculation
          F_perp_RMS(iimage) = PATH_RMS(n3,F_perp(1:n3))
          F_para_RMS(iimage) = PATH_RMS(n3,F_para(1:n3))
          Fs_para_RMS(iimage) = PATH_RMS(n3,Fs_para(1:n3))

          ! Debug log
          if(maswrk.and.debug) then
              write(iw,'(a)') 'Debug: tau(unit)'
              write(iw,'(3f18.8)') tau(1:n3)
          endif
          if(maswrk.and.debug) then
              write(iw,'(a)') 'Debug: Elements of F_perp'
              write(iw,'(3f18.8)') F_perp(1:n3)
              write(iw,'(a)') 'Debug: RMS of F_perp'
              write(iw,'(f18.8)') F_perp_RMS(iimage)
          endif
          if(maswrk.and.debug) then
              write(iw,'(a)') 'Debug: Elements of F_para'
              write(iw,'(3f18.8)') F_para(1:n3)
              write(iw,'(a)') 'Debug: RMS of F_para'
              write(iw,'(f18.8)') F_para_RMS(iimage)
          endif
          if(maswrk.and.debug) then
              write(iw,'(a)') 'Debug: Elements of Fs_para'
              write(iw,'(3f18.8)') Fs_para(1:n3)
              write(iw,'(a)') 'Debug: RMS of Fs_para'
              write(iw,'(3f18.8)') Fs_para_RMS(iimage)
          endif
          if(maswrk.and.debug) then
              write(iw,*) 'Debug iimage:',iimage
              write(iw,'(a)') 'Debug: Elements of F(OPT)'
              write(iw,'(3f18.8)') F(1:n3,iimage)
              !write(iw,'(a)') 'Debug: RMS of F(OPT)'
              !write(iw,'(3f18.8)') F_RMS(iimage)
          endif
c
          call DDI_sync(320152+iimage)
      end do
c
c

      !-- Calculate value
      !   F_MAX : Max value of force at each images
      !   F_RMS : RMS value of force at each images
      !   F_MAX(0) : Max F_MAX value in all images
      !   F_RMS(0) : Max F_RMS value in all images
      !   D_MAX : Max value of displacement at each images
      !   D_RMS : RMS value of displacement at each images
      !   D_MAX(0) : Max D_MAX value in all images
      !   D_RMS(0) : Max D_RMS value in all images
      F_MAX(0)=0.0d0
      F_RMS(0)=0.0d0
      D_MAX(0)=0.0d0
      D_RMS(0)=0.0d0
      do iimage=1, nimages
          !Calculate F_MAX, D_MAX
          F_MAX(iimage) = abs(F(1,iimage))
          D_MAX(iimage) = abs(X(1,iimage) - hisX(1,iimage,2))
          do i=2,n3
              F_MAX(iimage) = max(F_MAX(iimage), abs(F(i,iimage)))
              D_MAX(iimage) = 
     &        max(D_MAX(iimage), abs(X(i,iimage) - hisX(i,iimage,2)))
          end do
          !Calculate F_RMS, D_RMS
          F_RMS(iimage) = PATH_RMS(n3,F(1:n3,iimage))
          D_RMS(iimage) = PATH_RMS(n3,(X(1:n3,iimage)
     &                         - hisX(1:n3,iimage,2)))
          !Calculate F_MAX(0), F_RMS(0), D_MAX(0), D_RMS(0)
          F_MAX(0)=max(F_MAX(0), F_MAX(iimage))
          F_RMS(0)=max(F_RMS(0), F_RMS(iimage))
          D_MAX(0)=max(D_MAX(0), D_MAX(iimage))
          D_RMS(0)=max(D_RMS(0), D_RMS(iimage))
      end do
      !-- Convergence check
      conv(1) = F_MAX(0) < OPMTOL
      conv(2) = F_RMS(0) < OPTTOL
      conv(3) = D_MAX(0) < CRMTOL
      conv(4) = D_RMS(0) < CRDTOL
      if (conv(1).and.conv(2).and.conv(3).and.conv(4)) then
          convflag = .true.
      else
          convflag = .false.
      end if

      !-- Data table and covergence check table
      call PATH_summary(iw,NAT,nimages,ZMASS,X,V,
     &               icycle,jcycle,i_CI,
     &               G_RMS,F_RMS,F_perp_RMS,F_para_RMS,Fs_para_RMS,
     &               F_MAX,D_MAX,D_RMS,
     &               OPMTOL,OPTTOL,CRMTOL,CRDTOL,conv,convflag,
     &               UNTCNT,TOANGS,TOKCAL,MASWRK,DEBUG)

      !-- Return subroutine
      if(convflag) then
          return
      end if

      if(jcycle==MAXCYC) then !reached maxcyc
          return
      end if
c
      !Convergence acceleration (now not working)
      !ichk = 0
      !jchk = 0
      !FTmax = zero
c     !do iimage=1,nimages
      !do iimage=2,(nimages-1)
      !    if(F_perp_RMS(iimage).gt.(opttol*100.0d+00)) then
      !        ichk=ichk+1
      !    end if
      !    if(F_perp_RMS(iimage).gt.(opttol*10.0d+00)) then
      !        jchk=jchk+1
      !    end if
      !    if(F_perp_RMS(iimage).gt.FTmax) then
      !        FTmax=F_Trms(iimage)
      !    end if
      !enddo
      !if(ichk.eq.0) then
      !    iswitch=1
      !end if
      !if((ichk.eq.0).and.(jchk.eq.0)) then
      !    iswitch=2
      !end if

      call DDI_sync(320155)
c
      !------------------------------------------
      !-- Optimization
      !   Since end images(1st and last images) are already optimized,
      !   end images are not optimized here.
      if(maswrk.and.debug) then
          write(iw,'(a,i4)') 'Optimization step icycle=',icycle
          write(iw,'(a,a)')  '               Optimizer=',optmzr
      end if

      do iimage=2,(nimages-1)
          if(maswrk.and.debug) then
              write(iw,*) 'Debug: iimage=',iimage
              call PATH_chem3d(iw,iimage,nat,ian,x(1,iimage),
     *                              TOANGS,MASWRK)
          end if
          threshold1=10 !HARUTA cleaned after..
          threshold2=20 !HARUTA cleaned after..
          displimit=0.145d0 !HARUTA cleaned after..

          call PATH_optimizer(IW,n3,iimage,OPTMZR,icycle,NUMHIS,
     &         X(1:n3,iimage),hisX(1:n3,iimage,1:numhis), 
     &         F(1:n3,iimage),hisF(1:n3,iimage,1:numhis), 
     &         InvHess(iimage,1:n3,iimage,1:n3),          
     &         threshold1,threshold2,                   
     &         dd(1:nat,1:nat),velo(1:n3,iimage),quickdt,
     &         displimit,                               
     &         maswrk,debug)
      enddo
      call DDI_sync(320156)
c
c
      if(maswrk.and.debug) then
          write(iw,'(a,2f20.10)') 'Debug: E(1)&E(n) =',V(1), V(nimages)
          do iimage=1,nimages
              call PATH_chem3d(iw,iimage,nat,ian,x(1,iimage),
     &                      TOANGS,MASWRK)
          enddo
      endif

      if(maswrk) then
          write(iw,'(a)') 'Start coordinate fitting...'
      endif
c
c     PATH_anglr...
c     do iimage=1,(nimages-2)    ! need to do for the final image...
      do iimage=1,(nimages-1)
          if(maswrk) then
              write(iw,'(a,i5)')
     &             '*** Coordinate fitting of #Image= ',iimage
          endif
          call PATH_anglr(iw,NAT,ANAM,BNAM,IAN,ZMASS,
!     &         X(1,iimage),X(1,iimage+1),CRDTOL, !nessasary??
     &         X(1,iimage),X(1,iimage+1),20.0d0, !nessasary??
     &         TAU_PLUS,TAU_MINUS,DC,DD,
     &         TOANGS,MASWRK,DEBUG)
c
      enddo
      call DDI_sync(320157)

      if(maswrk) then
          write(iw,'(a)') 'Finished coordinate fitting...'
      endif
c
      if(maswrk.and.debug) then
          write(iw,'(a,2f20.10)') 'Debug: E(1)&E(n) =',V(1), V(nimages)
          do iimage=1,nimages
              call PATH_chem3d(iw,iimage,nat,ian,x(1,iimage),
     &                      TOANGS,MASWRK)
          enddo
      endif
      call DDI_sync(320158)
c
c     Energy & Gradients

      ! Examine whether first image be calculated
      if(FSTEND=='FIXED') then
          calc_first=2
      else
          calc_first=1
      end if

      ! Examine whether last image be calculated
      if(LSTEND=='FIXED') then
          calc_last=nimages-1
      else
          calc_last=nimages
      end if

      !do iimage=2,(nimages-1)
      !do iimage=1,nimages
      do iimage=calc_first,calc_last
          if(maswrk) then
              write(iw,'(/,18("-"),x,a,i5,a,i5,x,18("-"))')
     &       'ENERGY and GRADIENT calculation #IMAGE=',
     &       iimage,'    icycle=',icycle
          end if
c
c         if((iimage.gt.1).and.(.not.debug)) NPRINT =-5
c         if(.not.debug) NPRINT =-5
          if(debug) then
             NPRINT =5
             !NPRINT =-5
          else
             NPRINT =-5
          endif
c                       NPRINT =-5      ! minimal
c                       NPRINT = 3      ! 1e
c                       NPRINT = 5      ! scf
c                       NPRINT = 7      ! normal
c                       NPRINT = 9      ! maximum
c

          !-- avoid too many logs --!
          if(DBGLOG) then           !
              debug = .false.       !
          else                      !
              debug = .false.       !
          end if                    !
          !-------------------------!

c         !Load the information of the current image...
          j0 = 0
          do i=1,nat
              do j=1,3
                  j0 = j0 +1
                  c(j,i) = x(j0,iimage)
              enddo
          enddo
          store(1:nstore) = zero
          ENERGY = zero
          EGRAD(1:n3) = zero
c
          call DAREAD(IDAF,IODA,STORE,nstore,iREC(iimage),0)
          if(maswrk) then
              write(iw,'(a,i5,a,i5)')
     *       'Read the previous data at #IMAGE=',iimage,
     *       ' from IREC=',IREC(iimage)
          end if
c
c         alpha orbitals...
          call DAWRIT(IDAF,IODA,STORE(n3x2+1),L3,15,0)
          if(maswrk) then
              write(iw,'(a,i5)')
     *       'Store the alpha orbitals at #IMAGE=',iimage
          end if
c
c         beta orbitals, if necessary
          IF(SCFTYP.EQ.SCFUHF) THEN
              call DAWRIT(IDAF,IODA,STORE(n3x2+istoreb),L3,19,0)
              if(maswrk) then
                  write(iw,'(a,i5)')
     *          'Store the beta orbitals at #IMAGE=',iimage
              end if
          endif
c
          if(maswrk) then
              write(iw,'(/a,i5)')
     &             '*** Coordinate [bohr] of #IMAGE=',iimage
              !write(iw,'(a,4i5)')'Debug: NAT,n3,NUM,NE=',NAT,n3,NUM,NE
              do i=1,nat
                  write(iw,'(1x,a8,a2,1x,F5.1,3F18.10)') 
     &                 ANAM(i),BNAM(i),ZAN(i),(C(j,i),j=1,3)
     &            !     ,ZMASS(i),IAN(i)
              enddo
          endif
          call DDI_sync(320159+iimage)
c
          if(maswrk) then
              write(iw,'(/a/)')
     *       '*** START A SINGLE POINT CALCULATION ***'
          end if

          call DDI_sync(10000+iimage)
          CALL ENERGX
          call DDI_sync(10001+iimage)
c
          !Failed to obtain energy.. (SCF failure)
          if(ENERGY.eq.ZERO) then
              if(maswrk) then
                  write(iw,'(a)')
     &                 'ERROR: failed to obtain a total energy...'
                  write(iw,'(a)')'The structure may be broken.'
                  write(iw,'(a)')'ALL CALCULATION will be aborted.'
              end if
              abortflag = .true.
              return
          endif

          call DDI_sync(320160+iimage)
c
          if(maswrk) then
              write(iw,'(/a/)') '*** START A GRADIENT CALCULATION ***'
          end if
          IF (CITYP.EQ.CIGUGA) then
              CALL CIGRAD
          ELSE
              CALL HFGRAD
          END IF
          call DDI_sync(320161+iimage)
c
c         ------------------------------------------
c         Restore the data into the dictionary file...
c         (iimage, Energy) C, EGRAD, VEC(alpha&beta)
c
          do i=1,n3
              STORE(i) = X(i,iimage)
              STORE(n3+i) =-EGRAD(i)
          enddo
c
c         alpha orbitals...
          call DAREAD(IDAF,IODA,STORE(n3x2+1),L3,15,0)
          if(maswrk) then
              write(iw,'(a,i5)')
     *       'Read the alpha orbitals at #IMAGE=',iimage
          end if
c         debug print...
c         CALL PUSQL(STORE(n3x2+1),iw,L1,L1)
c
c         beta orbitals, if necessary
          IF(SCFTYP.EQ.SCFUHF) THEN
              call DAREAD(IDAF,IODA,STORE(n3x2+istoreb),L3,19,0)
              if(maswrk) then
                  write(iw,'(a,i5)')
     *           'Read the beta orbitals at #IMAGE=',iimage
              end if
          endif
c
          call DAWRIT(IDAF,IODA,STORE,nstore,iREC(iimage),0)
c        ------------------------------------------
          if(maswrk) then
              write(iw,'(a,i5)')
     *      'Store the information at #IMAGE=',iimage
          end if
          call DDI_sync(320162+iimage)
c
          V(iimage)      = ENERGY
          F(1:n3,iimage) = -EGRAD(1:n3)
          G_RMS(iimage)   = PATH_RMS(n3,EGRAD(1:n3))
c
          if(maswrk) then
              write(iw,'(/2a,i5)')
     &             '*** Energy [hartree] and ',
     &             'Gradient [hartree/bohr] of #IMAGE=',iimage
              write(iw,'(a,f20.10,6x,a,f20.10)')
     &             'Energy =',V(iimage),'G_RMS =',G_RMS(iimage)
              ie = 0
              do i=1,nat
                  is=ie+1
                  ie=ie+3
                  write(iw,'(a,i5,2x,a8,a2,a,3f20.10)')
     &                 '#atom',i,ANAM(i),BNAM(i),'EGRAD = ',
     &                 (EGRAD(j),j=is,ie)
              enddo
          endif

c
          !-- avoid too many logs --!
          if(DBGLOG) then           !
              debug = .true.        !
          else                      !
              debug = .false.       !
          end if                    !
          !-------------------------!

      enddo
      call DDI_sync(320163)
c
c   
      end subroutine PATH_main





C*MODULE NEBPATH *DECK PATH_summary
C>
C>    @brief    NEBPATH: Print out the data sheets at every cycles
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_summary(iw,NAT,nimages,ZMASS,X,V,
     &               icycle,jcycle,i_CI,
     &               G_RMS,F_RMS,F_perp_RMS,F_para_RMS,Fs_para_RMS,
     &               F_MAX,D_MAX,D_RMS,
     &               OPMTOL,OPTTOL,CRMTOL,CRDTOL,conv,convflag,
     &               UNTCNT,TOANGS,TOKCAL,MASWRK,DEBUG)
      implicit none
      integer, intent(in) :: iw, NAT, nimages
      double precision, intent(in) :: ZMASS(1:NAT)
      double precision, intent(in) :: X(1:3,1:NAT,nimages)
      double precision, intent(in) :: V(1:nimages)
      integer, intent(in) :: icycle, jcycle, i_CI
      double precision, intent(in) :: G_RMS(1:nimages)
      double precision, intent(in) :: F_MAX(0:nimages)! (0) is maximum of all
      double precision, intent(in) :: F_RMS(0:nimages)! (0) is maximum of all
      double precision, intent(in) :: D_MAX(0:nimages)! (0) is maximum of all
      double precision, intent(in) :: D_RMS(0:nimages)! (0) is maximum of all
      double precision, intent(in) :: F_perp_RMS(1:nimages)
      double precision, intent(in) :: F_para_RMS(1:nimages)
      double precision, intent(in) :: Fs_para_RMS(1:nimages)
      double precision, intent(in) :: OPMTOL,OPTTOL,CRMTOL,CRDTOL
      logical, intent(in) :: conv(1:4)
      logical, intent(in) :: convflag
      double precision, intent(in) :: UNTCNT
      double precision, intent(in) :: TOANGS, TOKCAL
      logical, intent(in) :: MASWRK
      logical, intent(inout) :: DEBUG
      double precision, parameter :: ZERO=0.00D+00
      integer :: i, j, iimage
      double precision :: riimage, rimages, stotal
      character(len=1) :: CIlabel(1:nimages)
      logical :: CIflag
c
      if(.not.MASWRK) then
          return
      end if

      !-- Labeling Climbing image
      CIlabel = ' '
      if(i_CI==0) then
          CIflag = .false.
      else
          CIflag = .true.
          do i = 1,nimages
              if(i==i_CI) then
                  CIlabel(i) = '*'
              end if
          end do
      end if

      !-- TABLE
      if(maswrk) then
          write(iw,'(100("-"))')
          write(iw,'(31x,a)')'*** RESULTS OF THE CURRENT CYCLE ***'
          write(iw,'(100("-"))')
          write(iw,'(a,i0)')'       Total cycle = ',icycle
          write(iw,'(a,i0)')'     Current cycle = ',jcycle
          write(iw,'(a,i0)')'  Number of images = ',nimages
          !write(iw,'(a,a)') 'Unit of coordinate = ',UNTCNT
          write(iw,'(a,l1)')'       Convergence = ',convflag
          if(CIflag) then
              write(iw,'(a,i0)')'   Climbing image : ',i_CI
              write(iw,'(a)')   'Climbing image is labelled as *.'
          end if
          write(iw,'(a)')''
      end if

      !-- DATA TABLE OF DISTANCES, ENERGIES, AND FORCES
      if(maswrk) then
          write(iw,'(100("-"))')
          write(iw,'(22x,a)')
     &'*** DATA TABLE OF DISTANCES, ENERGIES, AND FORCES ***'
          write(iw,'(100("-"))')
          write(iw,'(13x,2a)')
     &'Distance [sqrt(u)*bohr]    Total Energy   Relative E      ',
     &'F(RAW)_RMS      F(OPT)_RMS'
          write(iw,'(2a)')
     &'#Image           Stotal       DeltaS       ',
     &'[hartree]   [kcal/mol]  [hartree/bohr]  [hartree/bohr]'
          stotal = ZERO
          do iimage=1,nimages
              !The distance between two images...
              rimages = ZERO
              if(iimage > 1) then
                  do i=1,NAT
                      riimage = ZERO
                      do j=1,3
                          riimage = riimage + ZMASS(i)
     &                      *(X(j,i,iimage)-X(j,i,iimage-1))**2
                      enddo
                      rimages = rimages +sqrt(riimage)
                  enddo
                  rimages = rimages/sqrt(float(nat))
                  stotal = stotal +rimages
              endif
              ! rimages : reaction coordinate [sqrt(u)*bohr]
              ! stotal : sum of reaction coordinate [sqrt(u)*bohr]
              write(iw,'(i6,a1,3x,2(1x,f12.6),1x,f15.6,
     &                   1x,f12.3,2(1x,f15.6))')
     &             iimage,CIlabel(iimage),stotal,rimages,
     &             V(iimage),(V(iimage)-V(1))*TOKCAL,
     &             G_RMS(iimage),F_RMS(iimage)
          enddo
          write(iw,'(a)')''
      end if



      !-- DATA TABLE OF FORCES [Bohr]
      !if(maswrk.and.UNTCNT=='BOHR') then
      if(maswrk) then
          write(iw,'(100("-"))')
          write(iw,'(27x,a)')
     &'*** DATA TABLE OF FORCES [hartree/bohr] ***'
          write(iw,'(100("-"))')
          write(iw,'(2a)')
     &'#Image          F(RAW)_RMS      F(OPT)_RMS     ',
     &'F(perp)_RMS     F(para)_RMS    Fs(para)_RMS'
          do iimage=1,nimages
              write(iw,'(i6,a1,3x,5(1x,f15.6))')
     &        iimage,CIlabel(iimage),G_RMS(iimage),F_RMS(iimage),
     &        F_perp_RMS(iimage),F_para_RMS(iimage),Fs_para_RMS(iimage)
          enddo
          write(iw,'(a)')''
      end if

      !-- DATA TABLE OF FORCES [Angs]
      !if(maswrk.and.UNTCNT=='ANGS') then
      if(maswrk) then
          write(iw,'(100("-"))')
          write(iw,'(27x,a)')
     &'*** DATA TABLE OF FORCES [kcal/mol/angs] ***'
          write(iw,'(100("-"))')
          write(iw,'(2a)')
     &'#Image          F(RAW)_RMS      F(OPT)_RMS     ',
     &'F(perp)_RMS     F(para)_RMS    Fs(para)_RMS'
          do iimage=1,nimages
              write(iw,'(i6,a1,3x,5(1x,f15.6))')
     &             iimage,CIlabel(iimage),G_RMS(iimage)*TOKCAL/TOANGS,
     &             F_RMS(iimage)*TOKCAL/TOANGS,
     &             F_perp_RMS(iimage)*TOKCAL/TOANGS,
     &             F_para_RMS(iimage)*TOKCAL/TOANGS,
     &             Fs_para_RMS(iimage)*TOKCAL/TOANGS
          enddo
          write(iw,'(a)')''
      end if

      !-- CONVERGENCE CHECK TABLE [Bohr]
      !if(maswrk.and.UNTCNT=='BOHR') then
      if(maswrk) then
          write(iw,'(100("-"))')
          write(iw,'(32x,a)')
     &'*** EXAMINATION OF CONVERGENCES 1 ***'
          write(iw,'(100("-"))')
          write(iw,'(21x,a,/,2a)')
     &'F(OPT) [hartree/bohr]             Displacement [bohr]',
     &'#Image                 MAX             RMS             ',
     &'MAX             RMS'
          do iimage=1,nimages
              write(iw,'(i6,a1,3x,4(1x,f15.6))')
     &             iimage,CIlabel(iimage),F_MAX(iimage),F_RMS(iimage),
     &                   D_MAX(iimage),D_RMS(iimage)
          end do
          write(iw,'(a10,4(1x,f15.6))')
     &'Maximum',F_MAX(0),F_RMS(0),D_MAX(0),D_RMS(0)
          write(iw,'(a10,4(1x,f15.6))')
     &'Tolerance',OPMTOL,OPTTOL,CRMTOL,CRDTOL
          write(iw,'(a10,4(1x,l15))')
     &'Converged?',conv(1),conv(2),conv(3),conv(4)
          if (convflag) then
              write(iw,'(a10,4x,2a)')
     &'Result',
     &'All value of examination are smaller than the tolerance.'
          else
              write(iw,'(a10,4x,2a)')
     &'Result',
     &'One or more value of examination are still 
     &larger than the torelance.'
          end if
          write(iw,'(a)')''
      end if

      !-- CONVERGENCE CHECK TABLE [Angs]
      !if(maswrk.and.UNTCNT=='ANGS') then
      if(maswrk) then
          write(iw,'(100("-"))')
          write(iw,'(32x,a)')
     &'*** EXAMINATION OF CONVERGENCES 2 ***'
          write(iw,'(100("-"))')
          write(iw,'(20x,a,/,2a)')
     &'F(OPT) [kcal/mol/angs]             Displacement [angs]',
     &'#Image                 MAX             RMS             ',
     &'MAX             RMS'
          do iimage=1,nimages
              write(iw,'(i6,a1,3x,4(1x,f15.6))')
     &   iimage,CIlabel(iimage),F_MAX(iimage)*TOKCAL/TOANGS,
     &            F_RMS(iimage)*TOKCAL/TOANGS,
     &            D_MAX(iimage)*TOANGS,D_RMS(iimage)*TOANGS
          end do
          write(iw,'(a10,4(1x,f15.6))')
     &'Maximum',F_MAX(0)*TOKCAL/TOANGS,F_RMS(0)*TOKCAL/TOANGS,
     &          D_MAX(0)*TOANGS,D_RMS(0)*TOANGS
          write(iw,'(a10,4(1x,f15.6))')
     &'Tolerance',OPMTOL*TOKCAL/TOANGS,OPTTOL*TOKCAL/TOANGS,
     &            CRMTOL*TOANGS,CRDTOL*TOANGS
          write(iw,'(a10,4(1x,l15))')
     &'Converged?',conv(1),conv(2),conv(3),conv(4)
          if (convflag) then
              write(iw,'(a10,4x,2a)')
     &'Result',
     &'All value of examination are smaller than the tolerance.'
          else
              write(iw,'(a10,4x,2a)')
     &'Result',
     &'One or more value of examination are still 
     &larger than the torelance.'
          end if
          write(iw,'(a)')''
      end if
      !--------------------------------------------

      if(maswrk) then
          write(iw,'(100("-"))')
          write(iw,'(///)')
          write(iw,'(30x,33("="))')
          if (convflag) then
              write(iw,'(32x,a)')'THE PATH IS NOW CONVERGED!!!!'
          else
              write(iw,'(32x,a)')'  The path is NOT converged'
          end if
          write(iw,'(30x,33("="))')
          write(iw,'(///)')
      end if

      end subroutine PATH_summary






C*MODULE NEBPATH *DECK PATH_com
C>
C>    @brief    NEBPATH: Move the coordinates to the center-of-mass
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE PATH_com(iw,nat,anam,bnam,ZMASS,C,MASWRK,debug)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      dimension  anam(*),bnam(*),zmass(*),C(3,*)
      dimension  com(3)
      logical    MASWRK, debug
      parameter (zero=0.0d+00)
c
      totm = zero
      do i=1,nat
         totm = totm + zmass(i)
         enddo
      do j=1,3
         com(j)=zero
         do i=1,nat
            com(j)=com(j)+zmass(i)*c(j,i)
            enddo
         enddo
      do j=1,3
         com(j)=com(j)/totm
         enddo
c
      do i=1,nat
         do j=1,3
            c(j,i) = c(j,i) -com(j)
            enddo
         if(MASWRK.and.debug)
     *      WRITE(IW,9020) ANAM(I),BNAM(I),ZMASS(I),(C(j,i),j=1,3)
         enddo
 9020 FORMAT(1x,a8,a2,1x,F10.4,3F18.10)
c
      return
      end







C*MODULE NEBPATH *DECK PATH_chemcraft
C>
C>    @brief    NEBPATH: Print out the input for Chemcraft in "xyz" format
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE PATH_chemcraft(iw,iimage,nat,ian,C,TOANGS,MASWRK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical      MASWRK
c
      character*2  ASYMB
C
      dimension  C(3,*), ian(*)
      dimension  CA(3)
c
      if(maswrk) write(iw,'(i0)') nat
      if(maswrk) write(iw,9001) iimage
      do i=1,nat
         ASYMB = "  "
         if(ian(i).eq.1)   ASYMB = "H "
         if(ian(i).eq.2)   ASYMB = "He"
         if(ian(i).eq.3)   ASYMB = "Li"
         if(ian(i).eq.4)   ASYMB = "Be"
         if(ian(i).eq.5)   ASYMB = "B "
         if(ian(i).eq.6)   ASYMB = "C "
         if(ian(i).eq.7)   ASYMB = "N "
         if(ian(i).eq.8)   ASYMB = "O "
         if(ian(i).eq.9)   ASYMB = "F "
         if(ian(i).eq.10)  ASYMB = "Ne"
         if(ian(i).eq.11)  ASYMB = "Na"
         if(ian(i).eq.12)  ASYMB = "Mg"
         if(ian(i).eq.13)  ASYMB = "Al"
         if(ian(i).eq.14)  ASYMB = "Si"
         if(ian(i).eq.15)  ASYMB = "P "
         if(ian(i).eq.16)  ASYMB = "S "
         if(ian(i).eq.17)  ASYMB = "Cl"
         if(ian(i).eq.18)  ASYMB = "Ar"
         if(ian(i).eq.19)  ASYMB = "K "
         if(ian(i).eq.20)  ASYMB = "Ca"
         if(ian(i).eq.21)  ASYMB = "Sc"
         if(ian(i).eq.22)  ASYMB = "Ti"
         if(ian(i).eq.23)  ASYMB = "V "
         if(ian(i).eq.24)  ASYMB = "Cr"
         if(ian(i).eq.25)  ASYMB = "Mn"
         if(ian(i).eq.26)  ASYMB = "Fe"
         if(ian(i).eq.27)  ASYMB = "Co"
         if(ian(i).eq.28)  ASYMB = "Ni"
         if(ian(i).eq.29)  ASYMB = "Cu"
         if(ian(i).eq.30)  ASYMB = "Zn"
         if(ian(i).eq.31)  ASYMB = "Ga"
         if(ian(i).eq.32)  ASYMB = "Ge"
         if(ian(i).eq.33)  ASYMB = "As"
         if(ian(i).eq.34)  ASYMB = "Se"
         if(ian(i).eq.35)  ASYMB = "Br"
         if(ian(i).eq.36)  ASYMB = "Kr"
         if(ian(i).eq.37)  ASYMB = "Rb"
         if(ian(i).eq.38)  ASYMB = "Sr"
         if(ian(i).eq.39)  ASYMB = "Y "
         if(ian(i).eq.40)  ASYMB = "Zr"
         if(ian(i).eq.41)  ASYMB = "Nb"
         if(ian(i).eq.42)  ASYMB = "Mo"
         if(ian(i).eq.43)  ASYMB = "Tc"
         if(ian(i).eq.44)  ASYMB = "Ru"
         if(ian(i).eq.45)  ASYMB = "Rh"
         if(ian(i).eq.46)  ASYMB = "Pd"
         if(ian(i).eq.47)  ASYMB = "Ag"
         if(ian(i).eq.48)  ASYMB = "Cd"
         if(ian(i).eq.49)  ASYMB = "In"
         if(ian(i).eq.50)  ASYMB = "Sn"
         if(ian(i).eq.51)  ASYMB = "Sb"
         if(ian(i).eq.52)  ASYMB = "Te"
         if(ian(i).eq.53)  ASYMB = "I "
         if(ian(i).eq.54)  ASYMB = "Xe"
         if(ian(i).eq.55)  ASYMB = "Cs"
         if(ian(i).eq.56)  ASYMB = "Ba"
         if(ian(i).eq.57)  ASYMB = "La"
         if(ian(i).eq.58)  ASYMB = "Cs"
         if(ian(i).eq.59)  ASYMB = "Cs"
         if(ian(i).eq.60)  ASYMB = "Cs"
         if(ian(i).eq.61)  ASYMB = "Cs"
         if(ian(i).eq.72)  ASYMB = "Hf"
         if(ian(i).eq.73)  ASYMB = "Ta"
         if(ian(i).eq.74)  ASYMB = "W "
         if(ian(i).eq.75)  ASYMB = "Re"
         if(ian(i).eq.76)  ASYMB = "Os"
         if(ian(i).eq.77)  ASYMB = "Ir"
         if(ian(i).eq.78)  ASYMB = "Pt"
         if(ian(i).eq.79)  ASYMB = "Au"
         if(ian(i).eq.80)  ASYMB = "Hg"
         if(ian(i).eq.81)  ASYMB = "Tl"
         if(ian(i).eq.82)  ASYMB = "Pb"
         if(ian(i).eq.83)  ASYMB = "Bi"
         if(ian(i).eq.84)  ASYMB = "Po"
         if(ian(i).eq.85)  ASYMB = "At"
         if(ian(i).eq.86)  ASYMB = "Rn"
c
         do j=1,3
            CA(j)=C(j,i)*TOANGS
            enddo
         if(maswrk) write(iw,9101) ASYMB,'   ',(cA(j),j=1,3)
         enddo
 9001 format('image =',i5)
 9101 format(a2,a,3f12.6)
c
      return
      end






C*MODULE NEBPATH *DECK PATH_chem3d
C>
C>    @brief    NEBPATH: Print out the input for Chem3d in "cc1" format
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE PATH_chem3d(iw,iimage,nat,ian,C,TOANGS,MASWRK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical      MASWRK
c
      character*2  ASYMB
C
      dimension  C(3,*), ian(*)
      dimension  CA(3)
c
      if(maswrk) write(iw,9000) nat,iimage
      do i=1,nat
         ASYMB = "  "
         if(ian(i).eq.1)   ASYMB = "H "
         if(ian(i).eq.2)   ASYMB = "He"
         if(ian(i).eq.3)   ASYMB = "Li"
         if(ian(i).eq.4)   ASYMB = "Be"
         if(ian(i).eq.5)   ASYMB = "B "
         if(ian(i).eq.6)   ASYMB = "C "
         if(ian(i).eq.7)   ASYMB = "N "
         if(ian(i).eq.8)   ASYMB = "O "
         if(ian(i).eq.9)   ASYMB = "F "
         if(ian(i).eq.10)  ASYMB = "Ne"
c
         if(ian(i).eq.11)  ASYMB = "Na"
         if(ian(i).eq.12)  ASYMB = "Mg"
         if(ian(i).eq.13)  ASYMB = "Al"
         if(ian(i).eq.14)  ASYMB = "Si"
         if(ian(i).eq.15)  ASYMB = "P "
         if(ian(i).eq.16)  ASYMB = "S "
         if(ian(i).eq.17)  ASYMB = "Cl"
         if(ian(i).eq.18)  ASYMB = "Ar"
c
         if(ian(i).eq.19)  ASYMB = "K "
         if(ian(i).eq.20)  ASYMB = "Ca"
c
         if(ian(i).eq.21)  ASYMB = "Sc"
         if(ian(i).eq.22)  ASYMB = "Ti"
         if(ian(i).eq.23)  ASYMB = "V "
         if(ian(i).eq.24)  ASYMB = "Cr"
         if(ian(i).eq.25)  ASYMB = "Mn"
         if(ian(i).eq.26)  ASYMB = "Fe"
         if(ian(i).eq.27)  ASYMB = "Co"
         if(ian(i).eq.28)  ASYMB = "Ni"
         if(ian(i).eq.29)  ASYMB = "Cu"
         if(ian(i).eq.30)  ASYMB = "Zn"
c
         if(ian(i).eq.31)  ASYMB = "Ga"
         if(ian(i).eq.32)  ASYMB = "Ge"
         if(ian(i).eq.33)  ASYMB = "As"
         if(ian(i).eq.34)  ASYMB = "Se"
         if(ian(i).eq.35)  ASYMB = "Br"
         if(ian(i).eq.36)  ASYMB = "Kr"
c
         if(ian(i).eq.37)  ASYMB = "Rb"
         if(ian(i).eq.38)  ASYMB = "Sr"
c
         if(ian(i).eq.39)  ASYMB = "Y "
         if(ian(i).eq.40)  ASYMB = "Zr"
         if(ian(i).eq.41)  ASYMB = "Nb"
         if(ian(i).eq.42)  ASYMB = "Mo"
         if(ian(i).eq.43)  ASYMB = "Tc"
         if(ian(i).eq.44)  ASYMB = "Ru"
         if(ian(i).eq.45)  ASYMB = "Rh"
         if(ian(i).eq.46)  ASYMB = "Pd"
         if(ian(i).eq.47)  ASYMB = "Ag"
         if(ian(i).eq.48)  ASYMB = "Cd"
c
         if(ian(i).eq.49)  ASYMB = "In"
         if(ian(i).eq.50)  ASYMB = "Sn"
         if(ian(i).eq.51)  ASYMB = "Sb"
         if(ian(i).eq.52)  ASYMB = "Te"
         if(ian(i).eq.53)  ASYMB = "I "
         if(ian(i).eq.54)  ASYMB = "Xe"
c
         if(ian(i).eq.55)  ASYMB = "Cs"
         if(ian(i).eq.56)  ASYMB = "Ba"
c
         if(ian(i).eq.57)  ASYMB = "La"
         if(ian(i).eq.58)  ASYMB = "Cs"
         if(ian(i).eq.59)  ASYMB = "Cs"
         if(ian(i).eq.60)  ASYMB = "Cs"
         if(ian(i).eq.61)  ASYMB = "Cs"
c
         if(ian(i).eq.72)  ASYMB = "Hf"
         if(ian(i).eq.73)  ASYMB = "Ta"
         if(ian(i).eq.74)  ASYMB = "W "
         if(ian(i).eq.75)  ASYMB = "Re"
         if(ian(i).eq.76)  ASYMB = "Os"
         if(ian(i).eq.77)  ASYMB = "Ir"
         if(ian(i).eq.78)  ASYMB = "Pt"
         if(ian(i).eq.79)  ASYMB = "Au"
         if(ian(i).eq.80)  ASYMB = "Hg"
c
         if(ian(i).eq.81)  ASYMB = "Tl"
         if(ian(i).eq.82)  ASYMB = "Pb"
         if(ian(i).eq.83)  ASYMB = "Bi"
         if(ian(i).eq.84)  ASYMB = "Po"
         if(ian(i).eq.85)  ASYMB = "At"
         if(ian(i).eq.86)  ASYMB = "Rn"
c
         do j=1,3
            CA(j)=C(j,i)*TOANGS
            enddo
         if(maswrk) write(iw,9100) ASYMB,i,(cA(j),j=1,3)
         enddo
 9000 format(2x,i5,' #image =',i5)
 9100 format(a2,i5,3f12.6)
c
      return
      end






C*MODULE NEBPATH *DECK PATH_dchk
C>
C>    @brief    NEBPATH: Examine the distances between two atoms
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE PATH_dchk(iw,nat,anam,bnam,Zmass,c0,c1,
     &                     crdtol,MASWRK,DEBUG)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      dimension  Zmass(*)
      dimension  c0(3,*), c1(3,*)
      dimension  anam(*), bnam(*)
      parameter  (zero=0.0d+00)
      logical    MASWRK, DEBUG
c
      if(MASWRK.and.debug) WRITE(IW,9000)
c
      ierr = 0
      do i=1,nat
         xdisp = zero
         do j=1,3
            xdisp = xdisp + Zmass(i)*(c0(j,i)-c1(j,i))**2
            enddo
         xdisp = sqrt(xdisp)
         if(MASWRK.and.debug) WRITE(IW,9020) ANAM(I),BNAM(I),ZMASS(I)
     *                            ,xdisp
         if(xdisp.gt.crdtol) ierr = ierr+1
         enddo
 9000 FORMAT(/,'*** Getting into PATH_dchk routine ***')
 9020 FORMAT(5x,a8,a2,1x,F10.4,F18.10,' sqrt(amu)*bohr')
c
      return
      end subroutine









!!!!!
!!!!!
!!!!C*MODULE NEBPATH *DECK COORDFIT
!!!!C>
!!!!C>    @brief    NEBPATH: Erase the angular momentaum between two sets of coordinates
!!!!C>
!!!!C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
!!!!C>              Osaka Prefecture University, Japan
!!!!C
!!!!      SUBROUTINE coord_fit(iw,nat,anam,bnam,ian,xmass,cs0,ct1,crdtol,
!!!!     *           ct1new,ct1bak,dist1,dist2,toangs,MASWRK,debug)
!!!!!
!!!!      integer,intent(in) :: iw, nat, nimages
!!!!      dimension  anam(nat), bnam(nat), ian(nat)
!!!!     !---------------------------------------------------------------------------
!!!!      subroutine coord_fit(n, X)
!!!!     !  All images are superimposed by translating and rotating the structure.
!!!!     !
!!!!     !---------------------------------------------------------------------------
!!!!      use utility, only: nimages
!!!!      use utility, only: atmnum
!!!!      use utility, only: irmsfit, usatm, nusatm
!!!!      use utility, only: errstop
!!!!      implicit none
!!!!      double precision,intent(inout)  :: X(:,:)
!!!!      integer,intent(in) :: n  !- number of qm atoms
!!!!      integer :: i, j, jj, k, nfit, fitatom(1:n)
!!!!      integer :: iusatm
!!!!      double precision :: cent1(1:3), cent(1:3), rotmat(1:3,1:3)
!!!!      double precision,allocatable :: coord1(:,:), coord2(:,:)
!!!!      double precision,allocatable :: Xcoord(:,:,:)
!!!!
!!!!
!!!!
!!!!      !-- Set Xcoord
!!!!      allocate(Xcoord(1:3,1:n,1:nimages))
!!!!      do i = 1, nimages
!!!!         do j = 1, n
!!!!            jj = (j - 1)*3 + 1
!!!!            Xcoord(1:3,j,i) = X(jj:jj+2,i)
!!!!         end do
!!!!      end do
!!!!      print '(a)', 'Before lrmsd fitting. RMS (A)'
!!!!      print '(6f12.7)',(RMS(n,Xcoord(1:3,1:n,1),Xcoord(1:3,1:n,i)), i = 1, nimages)
!!!!
!!!!      !-- Select fitting atom.
!!!!      fitatom(1:n) = 0
!!!!      select case( irmsfit )
!!!!      case (1)
!!!!         print '(/a)', 'fitting all atoms'
!!!!         fitatom(1:n) = 1
!!!!      case (2)
!!!!         print '(/a)', 'fitting all heavy atoms'
!!!!         do j = 1, n
!!!!            if ( atmnum(j) /= 1 ) fitatom(j) = 1
!!!!         end do
!!!!      case (3)
!!!!         print '(/a)', 'fitting user selected atoms'
!!!!         iusatm = 1
!!!!         do j = 1, n
!!!!            if ( iusatm <= nusatm ) then
!!!!               if ( usatm(iusatm) == j ) then 
!!!!                  fitatom(j) = 1
!!!!                  iusatm = iusatm + 1
!!!!               end if
!!!!            end if
!!!!         end do
!!!!         ! debug
!!!!         print '(a,i0)', 'The number of fitting atoms are ', iusatm - 1
!!!!      case default
!!!!         call errstop('irmsfit is illegal',0,'projfrc.f90')
!!!!      end select
!!!!      nfit = sum(fitatom) !- number of fitting atom.
!!!!
!!!!
!!!!      !-- Translate fitting atoms center of gravity to (0,0,0)
!!!!      do i = 1, nimages
!!!!         !-- Calc. center of fitting atoms.
!!!!         cent(1:3) = 0.d0
!!!!         do j = 1, n
!!!!            if ( fitatom(j) == 1 ) cent(1:3) = cent(1:3) + Xcoord(1:3,j,i)/dble(nfit)
!!!!         end do
!!!!         if ( i == 1 ) cent1(1:3) = cent(1:3)
!!!!
!!!!         !-- Translate Xcoord
!!!!         do j = 1, n
!!!!            Xcoord(1:3,j,i) = Xcoord(1:3,j,i) - cent(1:3)
!!!!         end do
!!!!      end do
!!!!      print '(/a)', 'After Translattion. RMS(A)'
!!!!      print '(6f12.7)',(RMS(n,Xcoord(1:3,1:n,1),Xcoord(1:3,1:n,i)), i = 1, nimages)
!!!!
!!!!      !-- Rotate
!!!!      allocate(coord1(1:3,1:nfit),coord2(1:3,1:nfit))
!!!!      do i = 1, nimages
!!!!         !- Set coord1, coord2
!!!!         k = 0
!!!!         do j = 1, n
!!!!            if ( fitatom(j) == 1 ) then
!!!!               k = k + 1
!!!!               coord2(1:3,k) = Xcoord(1:3,j,i)
!!!!            end if
!!!!         end do
!!!!         if ( i == 1 ) then
!!!!            coord1(1:3,1:nfit) = coord2(1:3,1:nfit)
!!!!            cycle
!!!!         end if
!!!!
!!!!         !- Rotate
!!!!         call lrmsd(coord1,coord2,nfit,rotmat)
!!!!         !Xcoord(1:3,1:n,i)=matmul(rotmat,Xcoord(1:3,1:n,i))
!!!!         if (abs(rotmat(1,1)) >= 0.8 .and. abs(rotmat(2,2)) >= 0.8 .and. abs(rotmat(3,3)) >= 0.8) then
!!!!            Xcoord(1:3,1:n,i)=matmul(rotmat,Xcoord(1:3,1:n,i))
!!!!         else
!!!!            Xcoord(1:3,1:n,i)=matmul(rotmat,Xcoord(1:3,1:n,i))
!!!!            print '(/a)', '**************************   WARNING   **************************'
!!!!            print '(a)',  'Maybe, fitting coordinates and reference coordinates is very similar.'
!!!!            print '(a)',  'Check your output coordinates.'
!!!!            print '(a)', '**************************   WARNING   **************************'
!!!!            print '(/a)',  'Rotation matrix'
!!!!            if (i == 2) then
!!!!               do k = 1, 3
!!!!                  print '(3f15.7)', rotmat(1:3,k)
!!!!               end do
!!!!            end if
!!!!            print '()'
!!!!         end if
!!!!         ! debug
!!!!         if (i == 2) then
!!!!            print '(/a)',  'Rotation Matrix'
!!!!            do k = 1, 3
!!!!               print '(3f15.7)', rotmat(1:3,k)
!!!!            end do
!!!!         end if
!!!!         ! end debug
!!!!
!!!!         !- Translate
!!!!         do j = 1, n
!!!!            jj = (j - 1)*3 + 1
!!!!            X(jj:jj+2,i) = Xcoord(1:3,j,i) + cent1(1:3)
!!!!         end do
!!!!      end do
!!!!      print '(/a)', 'After Rotation. RMS(A)'
!!!!      print '(6f12.7)',(RMS(n,Xcoord(1:3,1:n,1),Xcoord(1:3,1:n,i)), i = 1, nimages)
!!!!
!!!!      deallocate(coord1, coord2, Xcoord)
!!!!
!!!!      return
!!!!      contains
!!!!      function RMS(n, A, B)
!!!!         double precision, intent(in) :: A(1:3,1:n), B(1:3,1:n)
!!!!         integer, intent(in) :: n
!!!!         double precision :: RMS
!!!!         integer :: i
!!!!         RMS = 0.d0
!!!!         do i = 1, n
!!!!            RMS = RMS + (A(1,i) - B(1,i))**2
!!!!            RMS = RMS + (A(2,i) - B(2,i))**2
!!!!            RMS = RMS + (A(3,i) - B(3,i))**2
!!!!         end do
!!!!         RMS = sqrt(RMS/dble(3*n))
!!!!      end function
!!!!      end
!!!!!
!!!!!
!!!!!
!!!!!
!!!!!
!!!!!
!!!!!
!!!!!
!!!!!
!!!!!
!!!!!
!!!!!
!!!!!











C*MODULE NEBPATH *DECK PATH_anglr
C>
C>    @brief    NEBPATH: Erase the angular momentaum between two sets of coordinates
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE PATH_anglr(iw,nat,anam,bnam,ian,xmass,cs0,ct1,crdtol,
     *           ct1new,ct1bak,dist1,dist2,toangs,MASWRK,debug)
c     Need work area: cnew,cold, dist1(), dist2()
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      dimension  xmass(nat)
      dimension  cs0(3,nat), ct1(3,nat)
      dimension  anam(nat), bnam(nat), ian(nat)
      logical    MASWRK, debug
c
CCCCC CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC CCCCC
c     Rotation of the coordinates for the second (triplet) state...
CCCCC Angular momentum...                                  CCCCC
CCCCC                             Shiro KOSEKI, 2011/12/11 CCCCC
CCCCC CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC CCCCC
c     subroutine trprot(natom,cs0,ct1,xmass,debug,iw)
c
      PARAMETER    (zero=0.0D+00, one=1.0d+00, two=2.0d+00)
      parameter    (pi=dacos(-one))
      parameter    (pi180=180.0d+00/pi)
c     PARAMETER    (amtol=1.0d-05, dtol=5.0d+00)
c     PARAMETER    (amtol=1.0d-08, dtol=5.0d+00)
      PARAMETER    (amtol=1.0d-10, dtol=5.0d+00)
      !PARAMETER    (amtol=1.0d-8, dtol=5.0d+00) !HARUTA for RYZEN ...?
c     PARAMETER    (amtol=1.0d-12, dtol=5.0d+00)
c                                  ~~~~~~~~~~~~ *****
c                   0.000000000010
c                     123456789012
c
      DIMENSION    ct1new(3,nat), ct1bak(3,nat)
      DIMENSION    DIST1(nat,nat)
      DIMENSION    DIST2(nat,nat)
c
      dimension    com(3)
      dimension    rot(3,3), eig(3), rinv(3,3), rbak(3,3)
      dimension    chk(3,3), ekeep(3)
      dimension    work(9),ipiv(3)
c
      PARAMETER    (itermx=100)
      dimension    record(1:itermx), xdeg(1:3,1:itermx)
      dimension    determinant(1:itermx)
c
      if(MASWRK.and.debug) WRITE(IW,9000)
c     if(maswrk) write(iw,*) 'Debug: debug=',debug
 9000 FORMAT(/,'*** Getting into PATH_anglr routine ***')
c
c     clear arrays...
      record(1:itermx)=zero
      xdeg(1:3,1:itermx)=zero
      call DDI_sync(320100)
c
c     -------------------------------------------------
c     cs0 and ct1 in bohr...
c     -------------------------------------------------
c     already move to the Center of mass?
      call PATH_com(iw,nat,anam,bnam,xMASS,cs0,MASWRK,debug)
      call PATH_com(iw,nat,anam,bnam,xMASS,ct1,MASWRK,debug)
      call DDI_sync(320101)
c
c     Just check...
      call PATH_dstmtx(iw,nat,cs0,dist1,maswrk,debug)
c
c     Caution: dist1 will be used.
      call PATH_dstmtx(iw,nat,ct1,dist1,maswrk,debug)
      call DDI_sync(320102)
c
      if(maswrk.and.debug) then
         write(iw,*) ' '
         write(iw,*) 'Debug: cs0...'
         call PATH_chem3d(iw,0,nat,ian,cs0,TOANGS,MASWRK)
         write(iw,*) ' '
         write(iw,*) 'Debug: ct1...'
         call PATH_chem3d(iw,0,nat,ian,ct1,TOANGS,MASWRK)
c
         write(iw,*) ' '
         write(iw,*) 'Debug: xmass...'
         do i=1,nat
            write(iw,9012) i,xmass(i)
            enddo
         endif
      call DDI_sync(320103)
 9012 format(i5,f12.5)
c
c     Angular momentum...
      iter = 0
      ireverse = 0
  100 continue
c     Move to the Center of mass? (not necessary...?)
      call PATH_com(iw,nat,anam,bnam,xMASS,cs0,MASWRK,debug)
      call PATH_com(iw,nat,anam,bnam,xMASS,ct1,MASWRK,debug)
      call DDI_sync(320104)
c
      do j=1,3
         com(j) = zero
         enddo
      do i=1,nat
         com(1) = com(1) +xmass(i)*( cs0(2,i)*(ct1(3,i)-cs0(3,i))
     *                              -cs0(3,i)*(ct1(2,i)-cs0(2,i)) )
         com(2) = com(2) +xmass(i)*( cs0(3,i)*(ct1(1,i)-cs0(1,i))
     *                              -cs0(1,i)*(ct1(3,i)-cs0(3,i)) )
         com(3) = com(3) +xmass(i)*( cs0(1,i)*(ct1(2,i)-cs0(2,i))
     *                              -cs0(2,i)*(ct1(1,i)-cs0(1,i)) )
         enddo
      totamt = dsqrt(com(1)**2 +com(2)**2 +com(3)**2)
      if(maswrk.and.debug) then
          write(iw,20) (com(j),j=1,3)
      end if
      call DDI_sync(320105)
   20 format(/,'Angular momentum =',3f15.8)
c
      iter = iter+1
      record(iter) = totamt
      if(iter.gt.itermx) then
         if(maswrk) then
            write(iw,*) 'Failed to converge...'
            write(iw,9200) iter
            do i=1,iter
               write(iw,9022) i,record(i),(xdeg(j,i),j=1,3),
     *                        determinant(i)
               enddo
            call abrt
            endif
         endif
      call DDI_sync(320106)
 9022 format(i5,3x,f20.12,'   (',3f10.5,')',d20.10)
c
c     When the angular momentum increases, ...
c*    if((iter.gt.1).and.(record(iter).gt.record(iter-1))) call abrt
c     if((iter.gt.1).and.(record(iter).gt.record(iter-1))) then
      if(iter.gt.1) then
      if(record(iter).gt.record(iter-1)) then
          afact = 10.0d+00
          if(totamt.gt.100.0d+00) afact = 100.0d+00
          if(totamt.gt.200.0d+00) afact = 200.0d+00
          if(totamt.gt.300.0d+00) afact = 300.0d+00
          if(totamt.gt.500.0d+00) afact = 500.0d+00
          if(totamt.gt.1000.0d+00) afact = 1000.0d+00
          if(ireverse.eq.0) then
            ax = -ax/afact
            ay = -ay/afact
            az = -az/afact
            else
            ax =  ax/afact
            ay =  ay/afact
            az =  az/afact
            endif
          do i=1,nat
             do j=1,3
                ct1(j,i) = ct1bak(j,i)
                enddo
             enddo
          ireverse = ireverse +1
          go to 66
          endif
          endif
c
c     Examine the convergence...
      if(totamt.lt.amtol) then
         xdeg(1:3,iter) = zero
         go to 200
         endif
c
c     Get angles for the rotation of ct1...
c     This is the first-order approximation for a rotational matrix.
      ireverse = 0
      eig(1:3) = zero
      rot(1:3,1:3) = zero
c     do i=1,3
c        eig(i) = zero
c        do j=1,3
c           rot(j,i) = zero
c           enddo
c        enddo
      call DDI_sync(320107)
c
c     Rotation matrix...
      do i=1,nat
         rot(1,1) = rot(1,1) +xmass(i)*cs0(3,i)*ct1(1,i)
         rot(1,2) = rot(1,2) -xmass(i)*cs0(2,i)*ct1(1,i)
         rot(1,3) = rot(1,3) -xmass(i)*cs0(2,i)*ct1(2,i)
     *                       -xmass(i)*cs0(3,i)*ct1(3,i)
         rot(2,1) = rot(2,1) +xmass(i)*cs0(3,i)*ct1(2,i)
         rot(2,2) = rot(2,2) +xmass(i)*cs0(3,i)*ct1(3,i)
     *                       +xmass(i)*cs0(1,i)*ct1(1,i)
         rot(2,3) = rot(2,3) +xmass(i)*cs0(1,i)*ct1(2,i)
         rot(3,1) = rot(3,1) -xmass(i)*cs0(1,i)*ct1(1,i)
     *                       -xmass(i)*cs0(2,i)*ct1(2,i)
         rot(3,2) = rot(3,2) -xmass(i)*cs0(2,i)*ct1(3,i)
         rot(3,3) = rot(3,3) +xmass(i)*cs0(1,i)*ct1(3,i)
         eig(1) = eig(1) +xmass(i)*cs0(2,i)*ct1(3,i)
     *                   -xmass(i)*cs0(3,i)*ct1(2,i)
         eig(2) = eig(2) +xmass(i)*cs0(3,i)*ct1(1,i)
     *                   -xmass(i)*cs0(1,i)*ct1(3,i)
         eig(3) = eig(3) +xmass(i)*cs0(1,i)*ct1(2,i)
     *                   -xmass(i)*cs0(2,i)*ct1(1,i)
         enddo
      call DDI_sync(320108)
c
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "Rotation matrix..."
         endif
      do i=1,3
         if(maswrk.and.debug) write(iw,9050) (rot(i,j),j=1,3)
         ekeep(i) = eig(i)
         do j=1,3
            rinv(i,j) = rot(i,j)
            rbak(i,j) = rot(i,j)
            enddo
         enddo
      determinant(iter)
     *   = rot(1,1)*rot(2,2)*rot(3,3)
     *    +rot(1,2)*rot(2,3)*rot(3,1)
     *    +rot(1,3)*rot(2,1)*rot(3,2)
     *    -rot(1,1)*rot(3,2)*rot(2,3)
     *    -rot(1,2)*rot(2,1)*rot(3,3)
     *    -rot(1,3)*rot(2,2)*rot(3,1)
      if(maswrk.and.debug) then
         write(iw,9052) determinant(iter)
         write(iw,*) " "
         write(iw,*) "B matrix..."
         write(iw,9050) (eig(j),j=1,3)
         endif
      call DDI_sync(320109)
 9050 format(3f15.8)
 9052 format('||det|| =',d20.10)
c
c*    if(determinant(iter).lt.zero) stop
c
c     ------------------------------------------------------
c     inverse matrix of rot: Intel MKL routine...
      call dgels('N',3,3,1,rinv,3,eig,3,work,9,info)
c                 1  2 3 4 5    6  7  8 9    10 11
      if(maswrk.and.(info.ne.0)) then
         write(*,*) 'Error in dgels: info=',info
         call abrt
         endif
      call DDI_sync(320110)
c
c     answer = eig(j)
c     rot*eig = ekeep ?
c
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "Answer..."
         write(iw,9050) (eig(j),j=1,3)
         endif
c
c     Debug...
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "rot*eig..."
         endif
      do i=1,3
         chk(i,1) = zero
         do j=1,3
            chk(i,1) = chk(i,1) +rot(i,j)*eig(j)
            enddo
         enddo
      if(maswrk.and.debug) then
         write(iw,9050) (chk(i,1),i=1,3)
         write(iw,9050) (ekeep(i),i=1,3)
         endif
      errx = zero
      do i=1,3
         do j=1,3
            if(dabs(rot(j,i)).gt.errx) errx=dabs(rot(j,i))
            enddo
         enddo
      errx = errx*1.0d-10
      do i=1,3
         diff = dabs(chk(i,1)-ekeep(i))
         if(diff.gt.errx) call abrt
         enddo
      call DDI_sync(320111)
c
c
c     Rotational angles...
      ax = eig(1)
      ay = eig(2)
      az = eig(3)
c
c     declear parameters...
c     pi = dacos(-one)
c     dx = ax/pi*180.0d+00
c     dy = ay/pi*180.0d+00
c     dz = az/pi*180.0d+00
c     pi180 = 180.0d+00/pi
c
      dx = ax*pi180
      dy = ay*pi180
      dz = az*pi180
      atol = dtol/pi180
      if(maswrk.and.debug) then
         write(iw,9060) ax,ay,az," rad."
         write(iw,9060) dx,dy,dz," deg."
         write(iw,9062) dtol,atol
         endif
c
   66 continue
      if((dabs(ax).gt.atol).or.(dabs(ay).gt.atol).or.
     *   (dabs(az).gt.atol)) then
         axyz = dabs(ax)
         if(dabs(ay).gt.axyz) axyz = dabs(ay)
         if(dabs(az).gt.axyz) axyz = dabs(az)
c
         if(axyz.eq.zero) then
            afact = zero
            else
            afact = atol/axyz
            endif
c
         ax = ax*afact
         ay = ay*afact
         az = az*afact
c        dx = ax/pi*180.0d+00
c        dy = ay/pi*180.0d+00
c        dz = az/pi*180.0d+00
         dx = ax*pi180
         dy = ay*pi180
         dz = az*pi180
         if(maswrk.and.debug) then
            write(iw,9064) dtol
            write(iw,9060) ax,ay,az," rad."
            write(iw,9060) dx,dy,dz," deg."
            endif
         endif
      xdeg(1,iter) = dx
      xdeg(2,iter) = dy
      xdeg(3,iter) = dz
      call DDI_sync(320112)
 9060 format('Rotational angles =',3f12.5,a5)
 9062 format('Maximum angle     =',f12.5,' [deg] =',f12.5,' [rad]')
 9064 format('Use ',f3.1,' degree for rotation...')
c
c     Rotational matrix...
      rot(1,1) =  dcos(ax)*dcos(ay)
      rot(1,2) = -dsin(ax)*dcos(az) -dcos(ax)*dsin(ay)*dsin(az)
      rot(1,3) =  dsin(ax)*dsin(az) -dcos(ax)*dsin(ay)*dcos(az)
      rot(2,1) =  dsin(ax)*dcos(ay)
      rot(2,2) =  dcos(ax)*dcos(az) -dsin(ax)*dsin(ay)*dsin(az)
      rot(2,3) = -dcos(ax)*dsin(az) -dsin(ax)*dsin(ay)*dcos(az)
      rot(3,1) =  dsin(ay)
      rot(3,2) =  dcos(ay)*dsin(az)
      rot(3,3) =  dcos(ay)*dcos(az)
c
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "Rotational matrix..."
         endif
      do i=1,3
         if(maswrk.and.debug) write(iw,9050) (rot(i,j),j=1,3)
         chk(i,1) = rot(i,1)**2 + rot(i,2)**2 +rot(i,3)**2
         chk(i,2) = rot(1,i)**2 + rot(2,i)**2 +rot(3,i)**2
         enddo
      if(maswrk.and.debug) then
         write(iw,9180) (chk(i,1),i=1,3)
         write(iw,9180) (chk(i,2),i=1,3)
         endif
      call DDI_sync(320113)
 9180 format('Debug: Norm =',3f15.10)
c
c     New coordinate...
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "New coordinates of the next image..."
         endif
      dmax = zero
      do i=1,nat
         do j=1,3
            ct1new(j,i) = rot(j,1)*ct1(1,i)
     *                   +rot(j,2)*ct1(2,i)
     *                   +rot(j,3)*ct1(3,i)
            enddo
         dist = dsqrt( (ct1new(1,i)-ct1(1,i))**2
     *                +(ct1new(2,i)-ct1(2,i))**2
     *                +(ct1new(3,i)-ct1(3,i))**2 )
         if(dist.gt.dmax) dmax=dist
         distm = dist*dsqrt(xmass(i))
         if(maswrk.and.debug)
     *      write(iw,9010) i,xmass(i),(ct1new(j,i),j=1,3),dist,distm
         enddo
      if(maswrk.and.debug) write(iw,9182) dmax
      call DDI_sync(320114)
 9010 format(i3,f8.1,5f15.8)
 9182 format('Debug: maximum displace of atoms =',f15.10)
c
      do i=1,nat
         do j=1,3
            ct1bak(j,i) = ct1(j,i)
            ct1(j,i) = ct1new(j,i)
            enddo
         enddo
      call PATH_dstmtx(iw,nat,ct1,dist2,maswrk,debug)
      call PATH_dstchk(iw,nat,dist1,dist2,maswrk)
      call DDI_sync(3201100)
      go to 100
c
  200 continue
      if(maswrk) then
         write(iw,9200) iter
         do i=1,iter
            write(iw,9022) i,record(i),(xdeg(j,i),j=1,3),
     *                     determinant(i)
            enddo
         endif
      call DDI_sync(320115)
 9200 format(/,'*** Record of coordinate rotation ***',
     *  '    iteration =',i5,
     */,'#Iteration  Angular Momentum   Rotation angles [deg.] (x,y,z)',
     *  '    Determinant')
c
      return
      end






C*MODULE NEBPATH *DECK PATH_dstchk
C>
C>    @brief    NEBPATH: Examine the distances between two atoms
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_dstchk(iw,nat,dist1,dist2,maswrk)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      dimension  dist1(nat,nat)
      dimension  dist2(nat,nat)
      logical    maswrk
c
      parameter (zero=0.0d+00, one=1.0d+00, two=2.0d+00)
c     parameter (dtol = 1.0d-05)
      parameter (dtol = 1.0d-08)
c
c*    if(maswrk) write(iw,9000)
      ierr = 0
      do i=1,nat
         do j=1,nat
            diff=dabs(dist1(j,i)-dist2(j,i))
            if(maswrk.and.(diff.gt.dtol)) then
               ierr = ierr+1
               write(iw,9100) j,i,dist1(j,i),dist2(j,i),diff
               endif
            enddo
         enddo
c*    if(maswrk) write(iw,9110) ierr
 9000 format('PATH_dstchk: the coordinates for the next image',
     *       ' should be maintained after rotation.')
 9100 format('Error (dstchk):',2i5,3f12.6)
 9110 format('PATH_dstchk: ierr=',i5)
      return
      end





C*MODULE NEBPATH *DECK PATH_dstmtx
C>
C>    @brief    NEBPATH: Create the distance matrix
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_dstmtx(iw,nat,cc,dist,maswrk,debug)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      parameter (zero=0.0d+00, one=1.0d+00, two=2.0d+00)
      dimension  cc(3,nat)
      dimension  dist(nat,nat)
      logical    MASWRK, debug
c
      if(maswrk.and.debug) write(iw,*) 'Debug: coordinates in bohr...'
c
      do i=1,nat
         do j=1,nat
            dist(j,i) = dsqrt( (cc(1,j)-cc(1,i))**2
     *                        +(cc(2,j)-cc(2,i))**2
     *                        +(cc(3,j)-cc(3,i))**2)
            enddo
         enddo
c
      if(nat.gt.10) return
      if(maswrk.and.debug) then
         write(iw,*) ' '
         write(iw,*) 'Distance matrix in bohr ---'
         do i=1,nat
            write(iw,9100) i,(dist(i,j),j=1,nat)
            enddo
         endif
 9100 format(i3,12f10.6)
c
      return
      end







C*MODULE NEBPATH *DECK PATH_readcoord
C>
C>    @brief    NEBPATH: read coordination from input file
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_readcoord(ir,iw,keywrd,nat,c4,maswrk,debug)
      !IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      implicit none
      integer, intent(in) :: ir, iw, nat
      !dimension    c4(4,nat)
      double precision, intent(inout) :: c4(4,nat)
      logical :: maswrk,debug
      character(len=8) :: keywrd
      character(len=80) :: xline
      integer :: i, i0, j
c
      if(maswrk.and.debug) then
        write(iw,'(a)') 'DEBUG: getting into PATH_readcoord'
        write(iw,'(a,i4,i4)') 'DEBUG: ir,iw =',ir,iw
      end if
c
      rewind ir
  100 continue
      !read(ir,1,err=900,end=900) xline HARUTABUCKUP
      read(ir,'(a80)',err=900,end=900) xline
c     if(maswrk.and.debug) write(iw,1) xline
      call PATH_capital(xline)
      if(xline(1:8).ne.keywrd) go to 100
      do i=1,nat
         if(maswrk.and.debug) write(iw,*) 'Debug: ',i
         !read(ir,1,err=900,end=900) xline
         read(ir,'(a80)',err=900,end=900) xline
c        if(maswrk.and.debug) write(iw,1) xline
         do j=2,80
            if(xline(j:j).eq.' ') go to 120
            enddo
         go to 900
c
  120    continue
         i0 = j
         !if(maswrk.and.debug) write(iw,2) (xline(j:j),j=i0,80)
         !HARUTABKUP
         if(maswrk.and.debug) write(iw,'(80a1)') (xline(j:j),j=i0,80)
         read(xline(i0:80),*,err=900,end=900) (c4(j,i),j=1,4)
         enddo
c
      return
c
  900 continue
      if(maswrk) write(iw,9120) keywrd,xline
      call abrt
      return
!    1 format(a80) HARUTABKUP
!    2 format(80a1) HARUTABKUP
 9120 format(/,'Error: could not find ',a8,//,a80)
      end subroutine






!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_capital
C>
C>    @brief    NEBPATH: Change the characters into capitals
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_capital(xline)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      character*1  xline(80)
c
      do i=1,80
         if(xline(i).eq.'a') xline(i)='A'
         if(xline(i).eq.'b') xline(i)='B'
         if(xline(i).eq.'c') xline(i)='C'
         if(xline(i).eq.'d') xline(i)='D'
         if(xline(i).eq.'e') xline(i)='E'
         if(xline(i).eq.'f') xline(i)='F'
         if(xline(i).eq.'g') xline(i)='G'
         if(xline(i).eq.'h') xline(i)='H'
         if(xline(i).eq.'i') xline(i)='I'
         if(xline(i).eq.'j') xline(i)='J'
         if(xline(i).eq.'k') xline(i)='K'
         if(xline(i).eq.'l') xline(i)='L'
         if(xline(i).eq.'m') xline(i)='M'
         if(xline(i).eq.'n') xline(i)='N'
         if(xline(i).eq.'o') xline(i)='O'
         if(xline(i).eq.'p') xline(i)='P'
         if(xline(i).eq.'q') xline(i)='Q'
         if(xline(i).eq.'r') xline(i)='R'
         if(xline(i).eq.'s') xline(i)='S'
         if(xline(i).eq.'t') xline(i)='T'
         if(xline(i).eq.'u') xline(i)='U'
         if(xline(i).eq.'v') xline(i)='V'
         if(xline(i).eq.'w') xline(i)='W'
         if(xline(i).eq.'x') xline(i)='X'
         if(xline(i).eq.'y') xline(i)='Y'
         if(xline(i).eq.'z') xline(i)='Z'
         enddo
c
      return
      end
      








!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_linear_interp
C>
C>    @brief    NEBPATH: linear interpolation between reactant and product (via-point)
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_linear_interp(n3, nimages, cc)
c           call PATH_linear_interp(nat*3,nimages,X(LIMAGES))
c
c     The subroutine of linear interpolation between 1st and last images
c     *******************************************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: n3, nimages
      double precision, intent(inout) :: cc(n3,nimages)
      integer :: i, iimage
c
c     n3        : n3 = 3 * the number of atoms
c     nimages    : the number of images
c     cc        : Coordinates of atoms in all images
c   
c     New images are linear interpolated between 1st and last images.
      do iimage = 2, nimages - 1
         do i = 1, n3
            cc(i,iimage) = cc(i,1) +dble(iimage - 1)*(cc(i,nimages) 
     *                    -cc(i,1))/dble(nimages - 1)
            end do
         end do
      end subroutine PATH_linear_interp




      
!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_IDPP_interp
C>
C>    @brief    NEBPATH: IDPP modification of the linear interpolation
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_IDPP_interp(iw,nat, nimages, X, velo,v,f,
     &           ian,Zmass,
     *           crdtol,toangs, tau,tau_plus,tau_minus,F_T,Fs_pa,
     *           dc,dd,di, maxcycle, quickdt, spring, f_conv,
     *           maswrk,debug)
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      ! The subroutine of image dependent pair potential (IDPP) interpolation
      !
      ! References
      ! (1) Smidstrup, S.; Pedersen, A.; Stokbro, K.; Jonsson, H. Improved Initial
      ! Guess for Minimum Energy Path Calculations. J. Chem. Phys. 2014, 140 (21),
      ! 214106.
      !
      ! (2) Halgren, T. A.; Lipscomb, W. N. The Synchronous-Transit Method for
      ! Determining Reaction Pathways and Locating Molecular Transition States.
      ! Chem. Phys. Lett. 1977, 49 (2), 225-232.
      !
      !*******************************************************
      integer, intent(in) :: ian(nat), maxcycle
      double precision, intent(in) :: quickdt, spring, f_conv
      double precision, intent(inout) :: x(1:3,1:nat,nimages)
      double precision, intent(inout) :: velo(1:3,1:nat,1:nimages)
      double precision :: di(1:nat,1:nat,1:nimages), d1, dn
      double precision :: f(1:3,1:nat,1:nimages)
      double precision :: v(1:nimages)
      double precision :: tau(1:3,1:nat)
      double precision :: tau_plus(1:3,1:nat)
      double precision :: tau_minus(1:3,1:nat)
c
      double precision :: F_T(1:3,1:nat), Fs_pa(1:3,1:nat)
c     double precision    C1WORK(nat*3),C2WORK(nat*3)
c
      double precision :: tmp, tmpvec(1:3)
      integer :: i, ii, j, iimage, icycle
      double precision :: f_sum, f_max, v_sum, v_max, NEB_euclid_norm
      double precision :: NEB_unit_vec, PATH_dot_prod
c
      double precision  crdtol,toangs
      double precision  Zmass(nat)
c
      double precision  dc(nat,nat),dd(nat,nat)
c     double precision  D1WORK(nat,nat),D2WORK(nat,nat)
      logical           maswrk, debug
c
      PARAMETER (MXATM=2000, MXAO=8192)
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, TWO=2.0d+00)
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
c
      if(maswrk) write(iw,9000)
 9000 format(/,'*** Getting into PATH_IDPP_interp routine ***',/)
c
      ! nat       : number of atoms
      n3 = nat*3
c
      ! nimages   : number of images
      ! ian       : atomic number
      ! x = xx    : Coordinates of atoms in all images
      ! velo      : Velocity for quick-min
      ! quickdt=dt: Step size for quick-min
      ! di        : Distances between atoms in interpolated image
      !             The di is calculated using linear interpolation based on the
      !             values of d1 and dn (described later).
      !             This value is an ideal value that is different from the
      !             actual molecular structure.
      ! d1        : Distances between atoms in 1st image
      ! dn        : Distances between atoms in last image
      ! v         : Image dependent pair potential (IDPP)
      ! f         : IDPP force (Negative gradient of IDPP)
      ! tau       : Tangent vector to the path
      ! tau_plus  : Forward difference
      ! tau_minus : Backward difference
      ! F_T       : Force in the direction perpendicular to the tangent vector
      ! Fs_pa     : Spring force in the direction parallel to the tangent vector
      ! n         : The number of atoms (n = n3/3)
      ! maxcycle  : Maximum number of IDPP optimization iteration
      ! spring    : Spring constant of NEB
      ! f_conv    : Threshold of force. If (f_sum < f_conv) stop
      ! f_sum     : Sum of the forces applied to the 2nd to N-1th images
      ! f_max     : Muximum of the forces applied to the 2nd to N-1th images
      ! v_sum     : Sum of the velocities applied to the 2nd to N-1th images
      ! v_max     : Muximum of the velocities applied to the 2nd to N-1th images
c
      ! Debug
      if(maswrk.and.debug) then
         write(iw,'(a,5i5)') 'Debug: iw,nat,n3,nimages =',
     *                               iw,nat,n3,nimages
         do iimage=1,nimages
            write(iw,*) nat,'   --- Debug: iimage =',iimage
            ie = 0
            do i=1,nat
               write(iw,'(i3,3f12.6)') ian(i),(x(j,i,iimage),j=1,3)
               enddo
            enddo
         endif
      call DDI_sync(320120)
c
      !------------------------------------------
      !-- Calc. di
      !   di: distances between atoms in interpolated image
      !   d1: distances between atoms in 1st image
      !   dn: distances between atoms in last image
      call PATH_dstmtx(iw,nat,x(1,1,1),di(1,1,1),maswrk,debug)
      call PATH_dstmtx(iw,nat,x(1,1,nimages),di(1,1,nimages),
     &                 maswrk,debug)
      do i=1,nat
         do j=1,nat
            dd(j,i) = di(j,i,nimages)-di(j,i,1)
            dd(j,i) = dd(j,i)/float(nimages-1)
            enddo
         enddo
      call DDI_sync(320121)
c
      do iimage=2,(nimages-1)
         if(maswrk.and.debug) write(iw,9002) iimage
         do i=1,nat
            do j=1,nat
               di(j,i,iimage)=di(j,i,iimage-1)+dd(j,i)
               enddo
            enddo
         if(maswrk.and.debug) then
            do i=1,nat
               if(nat.le.10) then
                  write(iw,'(10f8.3)') (di(j,i,iimage),j=1,nat)
                  else
                  write(iw,'(10f8.3)') (di(j,i,iimage),j=1,10)
                  endif
               enddo
            endif
         end do
      call DDI_sync(320122)
 9002 format(/,'Debug: linear interporation of distance matrix',
     *         ' at #image=',i3)
c
c     !------------------------------------------
c     !-- Main cycles
      do icycle=1, maxcycle
         !------------------------------------------
         !-- Superimposition of all images
!DELETE         if(maswrk) write(iw,9100) icycle
         if(maswrk) then
             write(iw,'(a)')''
             write(iw,'(a,i5,a)')
     &        '-------------------- IDPP interpolation # Cycle =',icycle
     &        ,' --------------------'
         end if
c        call coord_fit(n3/3, nimages, atmnum, x(1:n3,1:nimages), 1)
c        call coord_fit(n3/3, nimages, ian,    x(1:n3,1:nimages), 1)
         do i=1,(nimages-1)
            if(maswrk.and.debug) write(iw,9102) i
c
c           ??? necessary... ?
            if(maswrk) then
                write(iw,'(a)')''
                write(iw,'(a,i5)')
     &          '*** Coordinate fitting of #Image= ',i
            endif
            call PATH_anglr(iw,nat,anam,bnam,ian,Zmass,
     *           X(1,1,i),X(1,1,i+1),crdtol,
     *           tau_plus,tau_minus,dc,dd,toangs,MASWRK,debug)
            enddo
!DELETE 9100 format(/,'IDPP interpolation # Cycle   =',i5)
 9102 format(/,'# i(image) =',i5)
c
         !------------------------------------------
         !-- Estimate energies(v) and forces(f) of IDPP
         if(maswrk.and.debug) write(iw,*) '*** PATH_IDPP_estimate ---'
         call PATH_IDPP_estimate(iw,nat,nimages,x(1:3,1:nat,1:nimages), 
     *           f(1:3,1:nat,1:nimages), v(1:nimages),
     *           dc(1:nat,1:nat),di(1:nat,1:nat,1:nimages),
     *           maswrk,debug)
c
         ! Debug
         if(maswrk.and.debug) then
            write(iw,'(a)') 'fx,fy,fz --- '
            do iimage=1,nimages
               write(iw,*) 'iimage=',iimage
               do i=1,nat
                  write(iw,'(3f18.8)') (f(j,i,iimage),j=1,3)
                  end do
               write(iw,*) 'v(',iimage,')=',v(iimage)
               enddo
            endif
c
         !------------------------------------------
         !-- End images conditions
         !   Optimize, fix, free-end etc.
         !   These are not supported now.
   
         !------------------------------------------
         !-- Intermediate images conditions
         !   Neb forces are calculated here.
         !   Foeces of end images(1st and last images) are not modified.
         do iimage = 2, nimages-1
            if(maswrk.and.debug) write(iw,*) 'Debug: iimage=',iimage
c
            ! Calculation of tangent vectors along the path
            tau_plus(1:3,1:nat) = X(1:3,1:nat,iimage+1)
     *                           -X(1:3,1:nat,iimage)
            !if(maswrk.and.debug) then
            !   write(iw,*) 'IDPPDebug: tau_plus'
            !   do i=1,nat
            !      write(iw,'(3f18.8)') (tau_plus(j,i),j=1,3)
            !      end do
            !   endif
c
            tau_minus(1:3,1:nat) = X(1:3,1:nat,iimage)
     *                            -X(1:3,1:nat,iimage-1)
            !if(maswrk.and.debug) then
            !   write(iw,*) 'IDPPDebug: tau_minus'
            !   do i=1,nat
            !      write(iw,'(3f18.8)') (tau_minus(j,i),j=1,3)
            !      end do
            !   endif
c
            tau(1:3,1:nat) = tau_plus(1:3,1:nat)
     *                      +tau_minus(1:3,1:nat)
c           tau(1:3,1:nat) = X(1:3,1:nat,iimage+1)
c    *                      -X(1:3,1:nat,iimage-1)
            !if(maswrk.and.debug) then
            !   write(iw,*) 'IDPPDebug: tau_1'
            !   do i=1,nat
            !      write(iw,'(3f18.8)') (tau(j,i),j=1,3)
            !      end do
            !   endif
c
c           tau(1:3,1:nat) = NEB_unit_vec(n3, tau(1:3,1:nat))
            call PATH_unit_vec2(n3,tau(1:3,1:nat))
            !if(maswrk.and.debug) then
            !   write(iw,*) 'IDPPDebug: tau_2'
            !   do i=1,nat
            !      write(iw,'(3f18.8)') (tau(j,i),j=1,3)
            !      end do
            !   endif
c
            ! Calculation of perpendicular forces
            ! These forces are perpendicular to the tangent vectors.
            F_T(1:3,1:nat) = f(1:3,1:nat,iimage)
     *         -PATH_dot_prod(n3,f(1:3,1:nat,iimage),tau(1:3,1:nat))
     *         *tau(1:3,1:nat)
c
            !if(maswrk.and.debug) then
            !   write(iw,*) 'IDPPDebug: F_T'
            !   do i=1,nat
            !      write(iw,'(3f18.8)') (F_T(j,i),j=1,3)
            !      end do
            !   endif

            ! Calculation of spring forces
            ! These forces are parallel to the tangent vectors.
            Fs_pa(1:3,1:nat) = tau_plus(1:3,1:nat)
     *                        -tau_minus(1:3,1:nat)
c           Fs_pa(1:3,1:nat) = X(1:3,1:nat,iimage+1)
c    *                    -two*X(1:3,1:nat,iimage)
c    *                        +X(1:3,1:nat,iimage-1)
            !if(maswrk.and.debug) then
            !   write(iw,'(a,f10.5)') 'IDPPDebug: Fs_pa'
            !   do i=1,nat
            !      write(iw,'(3f18.8)') (Fs_pa(j,i),j=1,3)
            !      end do
            !   endif
c
            Fs_pa(1:3,1:nat) = spring
     *        *PATH_dot_prod(n3, Fs_pa(1:3,1:nat),tau(1:3,1:nat))
     *        *tau(1:3,1:nat)
c
            !if(maswrk.and.debug) then
            !   write(iw,'(a,f10.5)') 'IDPPDebug: Fs_pa, spring =',spring
            !   do i=1,nat
            !      write(iw,'(3f18.8)') (Fs_pa(j,i),j=1,3)
            !      end do
            !   endif
c
            ! Calclation of resultant forces (NEB forces)
            ! Force values are overwritten here.
            f(1:3,1:nat,iimage) = F_T(1:3,1:nat) + Fs_pa(1:3,1:nat)
c
            !if(maswrk.and.debug) then
            !   fperp = NEB_euclid_norm(n3,F_T(1:3,1:nat))
            !   fpara = NEB_euclid_norm(n3,Fs_pa(1:3,1:nat))
            !   write(iw,'(a,f20.10)') 'IDPPDebug: f-perpendi =',fperp
            !   write(iw,'(a,f20.10)') 'IDPPDebug: f-parallel =',fpara
c           !   write(iw,*) 'Debug: f'
c           !   do i=1,nat
c           !      write(iw,'(3f18.8)') (f(j,i,iimage),j=1,3)
c           !      end do
            !   endif
c
            enddo      ! loop of iimage...
         call DDI_sync(320123+icycle)
   
         !------------------------------------------
         !-- Convergence check
         f_sum = zero
         f_max = zero
         v_sum = zero
         v_max = zero
         !if(maswrk.and.debug) write(iw,*) 'Debug: nimages=',nimages
         do iimage=2,(nimages-1)
c
            if(maswrk.and.debug) write(iw,'(a,2i5)')
     *         'Debug: f,v, iimage,nimages=',iimage,nimages
c                                          ***** ******
c
            f_sum = f_sum + NEB_euclid_norm(n3, f(1:3,1:nat,iimage))
            v_sum = v_sum + v(iimage)
c
            if(f_max < NEB_euclid_norm(n3, f(1:3,1:nat,iimage))) then
               f_max = NEB_euclid_norm(n3, f(1:3,1:nat,iimage))
               end if
            if ( v_max < v(iimage) ) v_max = v(iimage)
            end do
c
c
         ! Debug
c        if(maswrk.and.debug) write(iw,'(i18,4f18.10)')
c    *      icycle, f_sum, f_max, v_sum, v_max
         if(maswrk.and.debug) write(iw,'(a,i8,a,5f18.10)') 'icycle=',
     &   icycle,': f,v =', f_sum, f_max, f_conv, v_sum, v_max
c                   -------------------------------------
c
         if ( f_sum < f_conv ) return
c        ****************************
c
         !------------------------------------------
         !-- Optimize
         if (icycle == 1) velo(1:3,1:nat,1:nimages) = zero
         do iimage =2,(nimages-1)
            if(maswrk.and.debug) write(iw,*) 'Debug: iimage=',iimage
            call PATH_quick_min(iw,n3, nimages, x(1:3,1:nat,iimage), 
     *                  f(1:3,1:nat,iimage), dd(nat,nat),
     *                  velo(1:3,1:nat,iimage),
     *                  quickdt,iimage,maswrk,debug)
            end do
c        Caution: dd has nat*nat dimension, but only nat*3 area will be used.
c
c
c.@2019/03/05-SK
c
         ! Debug
         if(maswrk.and.debug) then
            write(iw,*) 'Debug: NEB_dbg_write'
            do iimage=1,nimages
c              write(iw,'(i3,a,2i5)') nat,
c    *              '   --- Debug: icycle,iimage=',icycle,iimage
c                           iimage is always 11...?
c
c              call PATH_dbg_write_xyz(iw,iimage,nat,icycle,ian,X)
               call PATH_chem3d(iw,iimage,nat,ian,x(1,1,iimage),
     *                     TOANGS,MASWRK)
               end do
            endif
         call DDI_sync(320124+icycle)
c.@@@    ------------------------
c        if(icycle.eq.1) then
c        if(icycle.ge.10) then
c        if(icycle.ge.100) then
c        if(icycle.ge.1000) then
c           if(maswrk.and.debug) then
c              write(iw,'(a)') ' '
c              write(iw,'(a,i5,a)') 'Debug: Coordinates after',icycle,
c    *                              ' cycle...'
c              do i=1,nimages
c                 call PATH_chem3d(iw,i,nat,ian,x(1,1,i),TOANGS,MASWRK)
c                 enddo
c              endif
c           call abrt
c           return
c           endif
c.@@@    ------------------------
         !IDPP NEB convergence failure.
         if(icycle==maxcycle) then
             if(MASWRK) then
                 write(iw,'(a)')'IDPP cycle has reached to max.',
     &                'IDPP seemed not to be converged.',
     &                'Change parameter :',
     &                'IPMXCY,IPDLTT,IPSPFC,IPOPTL',
     &                'and re-submit your job.'
             end if
             call abrt
         end if
         enddo ! end main cylces
      call DDI_sync(320125)
c
c     --------------
      if(maswrk.and.debug) then
         do i=1,nimages
            call PATH_chem3d(iw,i,nat,ian,x(1,1,i),TOANGS,MASWRK)
            enddo
         endif
c
      if(maswrk) write(iw,9900)
      call DDI_sync(320126)
 9900 format(/,'*** Exiting from PATH_IDPP_interp routine ***',/)
c
      end subroutine PATH_IDPP_interp







!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_IDPP_estimate
C>
C>    @brief    NEBPATH: IDPP estimation for moving atoms
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_IDPP_estimate(iw,nat,nimages, x, f, v, dc,di,
     *           maswrk,debug)
      ! The subroutine to evaluate IDPP and force of IDPP
      !*******************************************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical     maswrk, debug
      integer, intent(in) :: nat,nimages
      double precision, intent(in)  :: x(1:3,1:nat,1:nimages)

      double precision, intent(out) :: f(1:3,1:nat,1:nimages)
c     double precision             :: ff(1:3,1:nat,1:nimages)
c
      double precision, intent(out) :: v(1:nimages)
      double precision, intent(out) :: dc(1:nat,1:nat)
      double precision, intent(in)  :: di(1:nat,1:nat,1:nimages)

      double precision :: di4, di3
      double precision :: tmp, tmpvec(1:3), NEB_euclid_norm
      integer :: i, ii, j, iimage, icycle
      parameter (zero=0.0d+00, one=1.0d+00, two=2.0d+00)
c
      ! nat       : number of atoms
        n3 = 3*nat
c
      ! nimages    : number of images
      ! nat       : number of atoms
      ! x = xx    : Coordinates of atoms in all images
      ! di        : Distances between atoms in interpolated image
      !             di is calculated using linear interpolation based on the
      !             values of d1 and dn (described later).
      !             This value is an ideal value that is different from the
      !             actual molecular structure.
      ! di4       : di4 = di^4
      ! di3       : di3 = di^3
      ! d1        : Distances between atoms in 1st image
      ! dn        : Distances between atoms in last image
      ! dc        : Distances between atoms in computed image
      !             Unlike di, the dc indicates the distance of atoms corresponding to
      !             the structure of the molecule actually calculated.
      ! v         : Image dependent pair potential (IDPP)
      ! f = ff    : IDPP force (Negative gradient of IDPP)
c
      if(maswrk.and.debug) write(iw,9000)
 9000 format(/,'*** Getting into PATH_IDPP_estimate routine...')
c   
      !------------------------------------------
      !-- Estimate energies(v) and forces(f)
c
      v(1:nimages) = zero
      f(1:3,1:nat,1:nimages) = zero
      if(maswrk.and.debug) write(iw,'(5f15.6)') v(1:nimages)
c
      do iimage=2,(nimages-1)
         ! Debug
         if(maswrk.and.debug) then
            write(iw,*) 'Debug: iimage=',iimage
            call PATH_dstmtx(iw,nat,x(1,1,iimage),dc,maswrk,debug)
            write(iw,'(a,i3,2f15.6)') 'Debug: iimage=',iimage,
     *              di(4,1,iimage),dc(4,1)
            else
            call PATH_dstmtx(iw,nat,x(1,1,iimage),dc,maswrk,.false.)
            endif
c
         do i = 1, nat
            do j = 1, nat
c              di4 = di(i,j,iimage)**4.0d0
c              di3 = di(i,j,iimage)**3.0d0
               di4 = di(i,j,iimage)**4
               di3 = di(i,j,iimage)**3
               if ( j /= i ) then
                  v(iimage) = v(iimage)
     *                     + ((di(i,j,iimage) - dc(i,j))**2) /di4
c
c                 ff(1:3,i,iimage) = ff(1:3,i,iimage)
c    *               + (two/di4-two/(di3*dc(i,j))) *tmpvec(1:3)
c
                  f(1:3,i,iimage) = f(1:3,i,iimage)
     *               + (two/di4-two/(di3*dc(i,j)))
     *                 *(x(1:3,i,iimage) - x(1:3,j,iimage))
c
                  end if
               end do
c
            end do
c
         v(iimage) = v(iimage)/two   ! get v
c
         ! Debug
         if(maswrk.and.debug) then
            write(iw,'(10f10.6)') (f(j,1,iimage),j=1,3)
            write(iw,'(10f10.6)') (f(j,2,iimage),j=1,3)
            write(iw,'(f15.6)') v(iimage)
            end if
c
         end do
c
c     ------------------------
      do iimage = 2, nimages - 1
         if(maswrk.and.debug) write(iw,*) 'Debug: iimage=',iimage
         do i = 1, nat
            f(1:3,i,iimage) = -f(1:3,i,iimage)       ! get f
c           ii = 3*(i - 1)
c           f(ii+1:ii+3,iimage) = - ff(1:3,i,iimage) ! get f
            end do
         end do
c     ------------------------
c
      if(maswrk.and.debug) write(iw,9100)
 9100 format(/,'*** Exiting from PATH_IDPP_estimate routine...')
c
      end subroutine PATH_IDPP_estimate








!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_dbg_write_xyz
C>
C>    @brief    NEBPATH: Debug writing of the coordinates
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_dbg_write_xyz(iw,iimage,natom,icycle,ian,X)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw,iimage, icycle, natom, ian(natom)
      double precision, intent(in) :: X(*)
      integer :: i
      character(len=128) :: file1
c
      !-- Write xyz file
      write(iw,'(i5,a,i5,a)') icycle, '.', iimage,'.xyz'
         write(iw,'(i5)') natom
         write(iw,'(2(a,i5))') ' cycle:', icycle, ', images:', iimage
         do i = 1, natom
            write(iw,'(i2,3x,3f25.16)') ian(i), X(3*i-2:3*i)
         end do
      end subroutine PATH_dbg_write_xyz







!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_dbg_3d_array
C>
C>    @brief    NEBPATH: Debug for 3D arrays
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_dbg_3d_array(iw,iimage,icycle,n,arr3d)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw,iimage, icycle, n
      double precision, intent(in) :: arr3d(:) ! arr3d(1:n)
      double precision :: NEB_euclid_norm
      integer :: i
      character(len=128) :: file1
c
         !-- Write xyz file
         write(iw,'(i0,a,i0,a)') icycle, '.', iimage, 
     *   '.dbg'
         write(iw,'(4a25)') 'X     ', 'Y     ', 'Z     ', 'Norm      '
         do i = 1, n/3
            write(iw,'(4f25.16)') arr3d(3*i-2:3*i), NEB_euclid_norm(3, 
     *      arr3d(3*i-2:3*i))
         end do
      end subroutine PATH_dbg_3d_array







!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_dbg_1d_array
C>
C>    @brief    NEBPATH: Debug for 1D arrays
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_dbg_1d_array(iw,iimage, icycle, n, arr1d)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw,iimage, icycle, n
      double precision, intent(in) :: arr1d(:) ! arr1d(1:n)
      integer :: i
      character(len=128) :: file1
c
         !-- Write xyz file
         write(iw,'(i0,a,i0,a)') icycle, '.', iimage, 
     *   '.dbg'
         write(iw,'(a25)') 'X     '
         do i = 1, n
            write(iw,'(f25.16)') arr1d(i)
         end do
      end subroutine PATH_dbg_1d_array








!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_optimizer
C>
C>    @brief    NEBPATH: Optimizer launcher
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_optimizer(iw,n3,iimage,optmzr,icycle,numhis,
     &     Xi,hisX, 
     &     Fi,hisF, 
     &     InvHess,          
     &     threshold1,threshold2,                   
     &     uniFi,quickvelo,quickdt,
     &     displimit,                               
     &     maswrk,debug)
      implicit none
      integer, intent(in) :: iw, n3, iimage
      character(len=8), intent(in) :: optmzr
      integer, intent(in) :: icycle, numHis
      double precision, intent(inout) :: Xi(1:n3)
      double precision, intent(inout) :: HisX(1:n3,1:numHis)
      double precision, intent(inout) :: Fi(1:n3)
      double precision, intent(inout) :: HisF(1:n3,1:numHis)
      double precision, intent(inout) :: InvHess(1:n3,1:n3)
      integer, intent(in) :: threshold1, threshold2
      double precision, intent(inout) :: uniFi(1:n3)
      double precision, intent(inout) :: quickvelo(1:n3)
      double precision, intent(in)  :: quickdt
      integer, intent(in) :: displimit
      logical :: maswrk, debug
      integer :: nimages, imagesid
      nimages=1
      imagesid=iimage

      if (maswrk) then
       write(iw,'(a)')''
       write(iw,'(a,i6)')'STARTING OPTIMIZING PROCESS... icycle=',icycle
       write(iw,'(a)')''
      endif

      !-Input variable check---------------------------------------------------
      if (threshold1 > threshold2) then
       write(iw,'(a)')'ERROR: threshold2 must be grater than
     & or equal to threshold1.'
       write(iw,'(a,i0)')'ERROR: threshold1 = ',threshold1
       write(iw,'(a,i0)')'ERROR: threshold2 = ',threshold2
       call abrt
      end if

      !------------------------------------------------------------------------
      if (optmzr == 'QUICKMIN') then

          if (maswrk) then
           write(iw,'(a,i6,a,i6)') 
     &     'OPT: QUICKMIN icycle=',icycle,',iimage=',iimage
          end if
          call PATH_quick_min(iw,n3,nimages,Xi,Fi,uniFi,quickvelo,
     &    quickdt,imagesID,maswrk,debug)

      !------------------------------------------------------------------------
      else if (optmzr == 'STEEPEST') then

          if (maswrk) then
           write(iw,'(a,i6,a,i6)') 
     &     'OPT: STEEPEST DESCENT icycle=',icycle,',iimage=',iimage
          end if
          call PATH_steepest_descent(iw,n3,Xi,Fi,
     &               quickdt,maswrk,debug)

      !------------------------------------------------------------------------
      else if (optmzr == 'BFGS') then

          if (maswrk) then
           write(iw,'(a,i6,a,i6)') 
     &     'OPT: BFGS icycle=',icycle,',iimage=',iimage
          end if
         ! call PATH_moveup_history(iw,n3,numHis,Xi,HisX,Fi,HisF,
     &   ! maswrk,debug)
          call PATH_BFGS(iw,n3,nimages,Xi,HisX,Fi,HisF,InvHess,
     &    threshold1,numHis,displimit,imagesID,icycle,maswrk,debug)

      !------------------------------------------------------------------------
      else if (optmzr == 'DIISBFGS') then

          if (maswrk) then
           write(iw,'(a,i6,a,i6)') 
     &     'OPT: DIIS+BFGS icycle=',icycle,',iimage=',iimage
           !write(iw,'(a)')'OPT: QMIN -> BFGS -> DIIS+BFGS'
          end if
         ! call PATH_moveup_history(iw,n3,numHis,Xi,HisX,Fi,HisF,
     &   ! maswrk,debug)

          if (icycle < threshold1 ) then

           if (maswrk) then
            write(iw,'(a,i6,a,i6)') 
     &      'OPT: QUICKMIN icycle=',icycle,',iimage=',iimage
           end if
           call PATH_quick_min(iw,n3,nimages,Xi,Fi,uniFi,quickvelo,
     &     quickdt,imagesID,maswrk,debug)

          else if (icycle < threshold2) then

           if(maswrk) then
            write(iw,'(a,i4,a,i6)')
     &      'OPT: BFGS icycle=',icycle,',iimage=',iimage
           endif
           call PATH_BFGS(iw,n3,nimages,Xi,HisX,Fi,HisF,InvHess,
     &     threshold1,numHis,displimit,imagesID,icycle,maswrk,debug)

          else if (icycle >= threshold2) then

           if(maswrk) then
            write(iw,'(a,i4,a,i6)')
     &      'OPT: DIIS+BFGS icycle=',icycle,',iimage=',iimage
           endif
           call PATH_DIIS_extrapolation(iw,n3,Xi,HisX,Fi,HisF,
     &     threshold2,numHis,icycle,maswrk,debug)
           call PATH_BFGS(iw,n3,nimages,Xi,HisX,Fi,HisF,InvHess,
     &     threshold1,numHis,displimit,imagesID,icycle,maswrk,debug)

          end if

      !------------------------------------------------------------------------
      else if (optmzr == 'QMINBFGS') then

          if (maswrk) then
           write(iw,'(a,i6,a,i6)') 
     &     'OPT: QMIN+BFGS icycle=',icycle,',iimage=',iimage
           !write(iw,'(a)')'OPT: QMIN -> BFGS'
          end if
         ! call PATH_moveup_history(iw,n3,numHis,Xi,HisX,Fi,HisF,
     &   ! maswrk,debug)

          if (icycle < threshold1 ) then

           if (maswrk) then
            write(iw,'(a,i6,a,i6)') 
     &      'OPT: QUICKMIN icycle=',icycle,',iimage=',iimage
           end if
           call PATH_quick_min(iw,n3,nimages,Xi,Fi,uniFi,quickvelo,
     &     quickdt,imagesID,maswrk,debug)

          else if (icycle >= threshold1) then

           if(maswrk) then
            write(iw,'(a,i4,a,i6)')
     &      'OPT: BFGS icycle=',icycle,',iimage=',iimage
           endif
           call PATH_BFGS(iw,n3,nimages,Xi,HisX,Fi,HisF,InvHess,
     &     threshold1,numHis,displimit,imagesID,icycle,maswrk,debug)

          end if

      !------------------------------------------------------------------------
      else if (optmzr == 'QBSWITCH') then

          if (maswrk) then
           write(iw,'(a,i6,a,i6)') 
     &     'OPT: QBSWITCH icycle=',icycle,',iimage=',iimage
          end if
         ! call PATH_moveup_history(iw,n3,numHis,Xi,HisX,Fi,HisF,
     &   ! maswrk,debug)

          if (icycle < threshold1 ) then

           if (maswrk) then
            write(iw,'(a,i6,a,i6)') 
     &      'OPT: QUICKMIN icycle=',icycle,',iimage=',iimage
           end if
           call PATH_quick_min(iw,n3,nimages,Xi,Fi,uniFi,quickvelo,
     &     quickdt,imagesID,maswrk,debug)

          else if (icycle >= threshold1) then

              if (mod(icycle,20) == 0
     &        .or.mod(icycle-1,20) == 0
     &        .or.mod(icycle-2,20) == 0
     &        .or.mod(icycle-3,20) == 0
     &        .or.mod(icycle-4,20) == 0) then

               if (maswrk) then
                write(iw,'(a,i6,a,i6)') 
     &          'OPT: QUICKMIN icycle=',icycle,',iimage=',iimage
               end if
               call PATH_quick_min(iw,n3,nimages,Xi,Fi,uniFi,quickvelo,
     &         quickdt,imagesID,maswrk,debug)

              else

               if(maswrk) then
                write(iw,'(a,i4,a,i6)')
     &          'OPT: BFGS icycle=',icycle,',iimage=',iimage
               endif
               call PATH_BFGS(iw,n3,nimages,Xi,HisX,Fi,HisF,InvHess,
     &         threshold1,numHis,displimit,imagesID,icycle,maswrk,debug)

              end if

          end if

      !------------------------------------------------------------------------
      else if (optmzr == 'ADAPTIVE') then

          if (maswrk) then
           write(iw,'(a,i6,a,i6)') 
     &     'OPT: ADAPTIVE icycle=',icycle,',iimage=',iimage
          end if
        !  call PATH_moveup_history(iw,n3,numHis,Xi,HisX,Fi,HisF,
     &  !  maswrk,debug)


          if (icycle < threshold1 ) then

           if (maswrk) then
            write(iw,'(a,i6,a,i6)') 
     &      'OPT: QUICKMIN icycle=',icycle,',iimage=',iimage
           end if
           call PATH_quick_min(iw,n3,nimages,Xi,Fi,uniFi,quickvelo,
     &     quickdt,imagesID,maswrk,debug)


          else if (icycle < threshold2) then

           if(maswrk) then
            write(iw,'(a,i4,a,i6)')
     &      'OPT: BFGS icycle=',icycle,',iimage=',iimage
           endif
           call PATH_BFGS(iw,n3,nimages,Xi,HisX,Fi,HisF,InvHess,
     &     threshold1,numHis,displimit,imagesID,icycle,maswrk,debug)

          else if (icycle >= threshold2) then

           if (mod(icycle,threshold2+10) == 0
     &     .or.mod(icycle-1,threshold2+10) == 0
     &     .or.mod(icycle-2,threshold2+10) == 0
     &     .or.mod(icycle-3,threshold2+10) == 0
     &     .or.mod(icycle-4,threshold2+10) == 0
     &     .or.mod(icycle-5,threshold2+10) == 0
     &     .or.mod(icycle-6,threshold2+10) == 0
     &     .or.mod(icycle-7,threshold2+10) == 0
     &     .or.mod(icycle-8,threshold2+10) == 0
     &     .or.mod(icycle-9,threshold2+10) == 0) then

            if (maswrk) then
             write(iw,'(a,i6,a,i6)') 
     &       'OPT: QUICKMIN icycle=',icycle,',iimage=',iimage
            end if
            call PATH_quick_min(iw,n3,nimages,Xi,Fi,uniFi,quickvelo,
     &      quickdt,imagesID,maswrk,debug)

           else

            if(maswrk) then
             write(iw,'(a,i4,a,i6)')
     &       'OPT: DIIS+BFGS icycle=',icycle,',iimage=',iimage
            endif
            call PATH_DIIS_extrapolation(iw,n3,Xi,HisX,Fi,HisF,
     &      threshold2,numHis,icycle,maswrk,debug)
            call PATH_BFGS(iw,n3,nimages,Xi,HisX,Fi,HisF,InvHess,
     &      threshold1,numHis,displimit,imagesID,icycle,maswrk,debug)

           end if

          end if

      else
          write(iw,'(a)') 'OPT: ERROR'
          write(iw,'(a,a)') 'OPT: YOUR SELECTED OPTMZR=',optmzr
          write(iw,'(a)') 'OPT: No such optimizer in this program.'
          call abrt
      end if

      end subroutine PATH_optimizer





!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_moveup_history
C>
C>    @brief    NEBPATH: Moving up history ID of Coord and Force
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_moveup_history(iw,n3,nimages,numHis,
     &                               Xi,HisX,Fi,HisF,
     &                              maswrk,debug)
      implicit none 
      !IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw, n3, numHis, nimages
      !double precision, intent(in) :: Xi(1:n3)
      double precision, intent(in) :: Xi(1:n3,1:nimages)
      !double precision, intent(inout) :: HisX(1:n3,1:numHis)
      double precision, intent(inout) :: HisX(1:n3,1:nimages,1:numHis)
      !double precision, intent(in) :: Fi(1:n3)
      double precision, intent(in) :: Fi(1:n3,1:nimages)
      !double precision, intent(inout) :: HisF(1:n3,1:numHis)
      double precision, intent(inout) :: HisF(1:n3,1:nimages,1:numHis)
      logical maswrk, debug
      integer :: m

      ! check
      if (numHis == 1) then
       write(iw,'(a)') 'ERROR: numHis = 1. Cannot moveup history.'
       call abrt
      end if

      ! moving up History ID 
      do m=numHis, 2, -1
         HisX(1:n3,1:nimages,m) = HisX(1:n3,1:nimages,m-1)
         HisF(1:n3,1:nimages,m) = HisF(1:n3,1:nimages,m-1)
      end do
      HisX(1:n3,1:nimages,1) = Xi(1:n3,1:nimages)
      HisF(1:n3,1:nimages,1) = Fi(1:n3,1:nimages)

      !if(maswrk.and.debug) then
      !write(iw,'(a)') '=====================DEBUG====================='
      !write(iw,'(a)') '              Moved up History ID'
      !write(iw,'(a)') '==============================================='
      !write(iw,'(a)') 'X'
      !write(iw,'(3f20.8)') Xi(1:n3)
      !do m=1,numHis
      !  write(iw,'(a,i0)') 'History of X ID= ',m
      !  write(iw,'(3f20.8)') hisX(1:n3,m)
      !end do
      !write(iw,'(a)') 'F'
      !write(iw,'(3f20.8)') Fi(1:n3)
      !do m=1,numHis
      !  write(iw,'(a,i0)') 'History of F ID= ',m
      !  write(iw,'(3f20.8)') hisF(1:n3,m)
      !end do
      !write(iw,'(a)') '====================/DEBUG====================='
      !endif

      end subroutine PATH_moveup_history
      




!-------------------------------------------------------------------------------
C*MODULE NEBPATH *DECK PATH_quick_min
C>
C>    @brief    NEBPATH: Quick minimization of gradients
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_quick_min(iw,n3,nimages,Xi,Fi,uniFi,
     *               quickvelo,quickdt,imagesID,maswrk,debug)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: n3, nimages, imagesID
      double precision, intent(inout) :: Xi(1:n3)
      double precision, intent(in)    :: Fi(1:n3)
      double precision, intent(inout) :: quickvelo(1:n3)
      double precision, intent(in)    :: quickdt
      integer :: i, j
      double precision :: uniFi(1:n3)
      double precision :: prod, mass, NEB_unit_vec
      double precision :: PATH_dot_prod
      character(len=16) :: fname
      logical   maswrk, debug
   
      ! n3        : n3 = 3 * the number of atoms
      ! nimages    : the number of images
      ! imagesID   : Serial number of image
      ! Xi        : Coordinates of atoms in all images
      ! Fi        : Force on atoms (negative gradient)
      ! quickvelo : Velocity for quick-min
      ! quickdt   : Step size for quick-min
   
      !------------------------------------------
      !-- Initialize quickvelo (quickvelo = 0)
   
      !-- Normalize force
c
c     uniFi(1:n3) = NEB_unit_vec(n3, Fi(1:n3))
      uniFi(1:n3) = Fi(1:n3)
      call PATH_unit_vec2(n3,uniFi(1:n3))
c
      !-- Project the velocity in the direction of the force
      prod = PATH_dot_prod(n3, quickvelo(1:n3), uniFi(1:n3))
c
      !-- Zero the velocity if it is antiparallel to the force
      if ( prod < 0.0d0 ) then
         quickvelo(1:n3) = 0.0d0
         if(maswrk.and.debug) print '(a,i0)',
     *    'PATH_quick_min: velocity was zero outed. imagesID =',imagesID
         else
         do i = 1, n3
            quickvelo(i) = prod*uniFi(i)
            end do
         end if
      !-- Take an Euler step,
      do i = 1, n3
         quickvelo(i) = quickvelo(i) + quickdt * Fi(i)
         Xi(i) = Xi(i) + quickdt * quickvelo(i)
         end do
      if(maswrk.and.debug) write(iw,'(a,i3,f10.3)')
     *         'Debug: n3,quickdt=',n3,quickdt
   
      end subroutine PATH_quick_min




C*MODULE NEBPATH *DECK PATH_steepest_descent
C>
C>    @brief    NEBPATH:Steepest Descent optimizer
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_steepest_descent(iw,n3,Xi,Fi,
     &               dt,maswrk,debug)
      implicit none
      !IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw, n3
      double precision, intent(inout) :: Xi(1:n3)
      double precision, intent(in)    :: Fi(1:n3)
      double precision, intent(in)    :: dt
      integer :: i
      logical   maswrk, debug
      ! n3        : n3 = 3 * the number of atoms
      ! Xi        : Coordinates of atoms in all images
      ! Fi        : Force on atoms (negative gradient)
      !------------------------------------------
      !dt = quickdt(0.01)
      do i = 1, n3
         !Xi(i) = Xi(i) + 0.05d0 * dt * Fi(i)
         Xi(i) = Xi(i) + 0.0005d0 * Fi(i)
      end do

      if (maswrk.and.debug) then
       write(iw,'(a,i3,f10.3)')'SD: n3,dt=',n3,dt
      end if
      end subroutine PATH_steepest_descent




C*MODULE NEBPATH *DECK PATH_DIIS_extrapolation
C>
C>    @brief    NEBPATH:DIIS convergence accelerator
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_DIIS_extrapolation(iw,n3,Xi,HisX,Fi,HisF,
     &           startcycle,numHis,icycle,maswrk,debug)
      implicit none 
      !IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw, n3
      double precision, intent(inout) :: Xi(1:n3)
      double precision, intent(in) :: HisX(1:n3,1:numHis)
      double precision, intent(inout) :: Fi(1:n3)
      double precision, intent(in) :: HisF(1:n3,1:numHis)
      integer, intent(in) :: startcycle
      integer, intent(in) :: numHis
      integer, intent(in) :: icycle
      logical maswrk, debug
      integer :: i,m,n
      integer :: dim
      double precision :: sum
      double precision, allocatable :: A(:),B(:)
      double precision :: Amax,Aelem
      character(len=1) :: uplo
      integer :: nrhs,lda,ldb,lwork,info
      integer,allocatable :: ipiv(:)
      double precision, allocatable :: work(:)
      double precision :: sumX, sumF
      if(maswrk.and.debug) then
       write(iw,'(a)') 'DIIS EXTRAPOLATION ROUTINE'
      end if

      !Pulay, P. Improved SCF Convergence Acceleration. J. Comput.
      !Chem. 1982, 3 (4), 556-560.
      
      ! Set the dimension of DIIS Matrix
      dim = icycle - startcycle + 1
      if (numHis < dim) then
          dim = numHis
      end if

      ! debug log
      if(maswrk.and.debug) then
      write(iw,'(a,i0)') 'DIIS: numhis= ',numhis
      write(iw,'(a,i0)') 'DIIS: icycle= ',icycle
      write(iw,'(a,i0)') 'DIIS: startcycle= ',startcycle
      write(iw,'(a,i0)') 'DIIS: dimension of iterative subspace= ',dim
      write(iw,'(a,i0)') 'DIIS: dimension of matrix A= ',dim+1
      end if

      ! Allocation and initialization of arrays
      allocate (A(1:(dim+1)*(dim+1)))
      allocate (B(1:(dim+1)))
      A = 0.0d0
      B = 0.0d0
      
      ! Construct the A matrix
      ! Error vector at HisID=i, e(i) = gradient(x1,y1,z1,x2,y2,...,ym,zm)
      if (maswrk.and.debug) then
       write(iw,'(a)') 'DIIS: Elements of matrix A'
      end if
      do m=1, dim
      do n=1, dim
       sum = 0.0d0
       do i=1, n3
        sum = sum + (-HisF(i,m)) * (-HisF(i,n))
       end do 
       A((m-1)*(dim+1)+n) = sum
!      if (maswrk.and.debug) then
!       write(iw,'(a,i2,a,i2,a,i2,a,i4,a,f20.8)') 
!     & 'DIIS: A((m-1)*(dim+1)+n) =
!     &  A(',m-1,'*(',dim,'+1)+',n,') = ',(m-1)*(dim+1)+n,' = ',sum
!      end if
      end do
      end do 

      !------------------------------
      ! The shape of Matrix A is 
      ! 1  2  3  4
      ! 5  6  7  8
      ! 9  10 11 12
      ! 13 14 15 16  (at 4-dim)
      ! 
      ! and 4,8,12,13,14,15 = 1
      !     16              = 0
      !------------------------------
      
      ! Find max value of A
      
      Amax = 0.0d0
      do m=1, dim
      do n=1, dim
       Aelem = dabs( A( (m-1)*(dim+1)+n ) )
       if ( Amax < Aelem ) then
            Amax = Aelem
       end if
      end do 
      end do 
      Amax = 1.0d0 / Amax

!      if(maswrk.and.debug) then
!      do m=1, dim
!       A((dim+1)*m) = 8888.888d0 !1.0d0 
!       A((dim+1)*dim+m) = 8888.888d0 !1.0d0
!      end do 
!       A((dim+1)*(dim+1)) = 8888.888d0 !0.0d0
!
!      write(iw,'(a)') 'DIIS: Matrix A before Normalize='
!      do m=1, dim+1
!       write(iw,'(9999f15.8)') A((dim+1)*(m-1)+1:(dim+1)*m)
!      end do
!      endif
      
      ! Scale elements of A
      do m=1, dim
      do n=1, dim
       A((m-1)*(dim+1)+n) = A((m-1)*(dim+1)+n) * Amax
      end do
      end do 
      
      ! Set the rightmost and bottommost lines
      do m=1, dim
       A((dim+1)*m) = 1.0d0       ! rightmost
       A((dim+1)*dim+m) = 1.0d0   ! bottommost
      end do 
       A((dim+1)*(dim+1)) = 0.0d0 ! lowerright

      ! Construct Vector B
      do m=1, dim
          B(m) = 0.0d0
      end do
          B(dim+1) = 1.0d0

      ! Debug log
      if (maswrk.and.debug) then
       write(iw,'(a)') 'DIIS: Matrix A='
       do m=1, dim+1
        write(iw,'(9999f15.8)') A((dim+1)*(m-1)+1:(dim+1)*m)
       end do
       write(iw,'(a)') 'DIIS: Vector B='
       write(iw,'(9999f15.8)') B
       write(iw,'(a)') 'DIIS: Solve AX = B...'
      end if
      
      ! Solve Ax = B
      uplo  = 'L'
      n     = dim + 1
      nrhs  = 1
      lda   = dim + 1
      allocate(ipiv(1:(dim+1)))
      ldb   = lda
      lwork = dim + 1
      allocate(work(1:lwork))
      info  = 999
      call dsysv(uplo,n,nrhs,A,lda,ipiv,B,ldb,work,lwork,info)
      
      ! debug log
      if (maswrk.and.debug) then
      write(iw,'(a)') 'DIIS: After solving Ax = B'
      write(iw,'(a)') 'DIIS: Details of the factorization of A ='
      do m=1, dim+1
       write(iw,'(9999f15.8)') A((m-1)*(dim+1)+1:(m-1)*(dim+1)+dim+1)
      end do
      write(iw,'(a)') 'DIIS: Solution X ='
      write(iw,'(9999f15.8)') B
      write(iw,'(a)') 'DIIS: Sum of vector X (Must be 1)='
      sum = 0.0d0
      do m=1,dim
          sum = sum + B(m)
      end do
      write(iw,'(f15.8)') sum
      write(iw,'(a)') 'DIIS: ipiv (Pivot indices) ='
      write(iw,'(9999i4)') ipiv(1:(dim+1))
      end if

      ! If dsysv routine was successfully completed,
      ! update the coordinates by the DIIS method
      if (info == 0) then 
       if(maswrk.and.debug) then
        write(iw,'(a,i2)') 'DIIS: LAPACK dsysv_, info=',info
       end if
       do i=1,n3 
        sumX = 0.0d0 
        sumF = 0.0d0
        do m=1,dim
         sumX = sumX + B(m) * HisX(i,m)
         sumF = sumF + B(m) * (-HisF(i,m))
        end do
        Xi(i)  = sumX
        Fi(i) = -sumF !force to gradient
       end do

      ! Skip DIIS coordinate update
      else

       if (maswrk.and.debug) then
        write(iw,'(a,i2)') 'DIIS: Incomplete LAPACK dsysv_, info=',info
       end if
       if (maswrk) then
        write(iw,'(a)') 'DIIS: Could not solve AX = B'
        write(iw,'(a)') 'DIIS: Skipping DIIS extrapolation.'
       end if
       continue
       
      end if
      
      end subroutine PATH_DIIS_extrapolation







C*MODULE NEBPATH *DECK PATH_BFGS
C>
C>    @brief    NEBPATH:BFGS optimizer
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_BFGS(iw,n3,nimages,Xi,HisX,Fi,HisF,InvHess,
     &         startcycle,numHis,displimit,imagesID,icycle,maswrk,debug)
      implicit none 
      !IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw, n3, nimages
      double precision, intent(inout) :: Xi(1:n3)
      double precision, intent(in) :: HisX(1:n3,1:numHis)
      double precision, intent(inout) :: Fi(1:n3)
      double precision, intent(in) :: HisF(1:n3,1:numHis)
      double precision, intent(inout) :: InvHess(1:n3,1:n3)
      integer, intent(in) :: startcycle
      integer, intent(in) :: numHis
      double precision,intent(in) :: displimit
      integer, intent(in) :: imagesID
      integer, intent(in) :: icycle
      logical   maswrk, debug
      double precision :: criterion_maxstep
      integer :: i,i1,i2
      double precision :: sum, alpha
      double precision :: dif
      double precision :: disp
      double precision :: Sk(1:n3),Yk(1:n3)
      double precision :: SkTYk
      double precision :: HkYk(1:n3)
      double precision :: SkSkT(1:n3,1:n3)
      double precision :: HkYkSkT(1:n3,1:n3)
      double precision :: SkHkYkT(1:n3,1:n3)
      double precision :: YkTHkYk 

      ! First BFGS cycle
      if (icycle==startcycle) then
      
       ! Initialize Inverted Hessian as Unit Matrix
       if (maswrk.and.debug) then
        write(iw,'(a)') 'BFGS: First BFGS cycle.'
        write(iw,'(a)') 
     &           'BFGS: Initialize Inverted Hessian as Unit Matrix'
       end if

       do i1=1, n3
       do i2=1, n3
        InvHess(i1,i2) = 0.0d0
       end do
        InvHess(i1,i1) = 1.0d0
       end do

      if(maswrk.and.debug) then
       write(iw,'(a)') 'BFGS: Initialized InvHess'
       do i1=1, n3
       write(iw,'(9999f6.3)') (InvHess(i1,i),i=1,n3)
       end do
      endif


      ! Not First BFGS cycle
      else
      

      ! Update Inverted Hessian Matrix
      ! Using BFGS method

      ! S_k
      Sk(1:n3) = HisX(1:n3,1) - HisX(1:n3,2)

      ! Y_k
      Yk(1:n3) = (-HisF(1:n3,1)) - (-HisF(1:n3,2))

      ! S_k^T * Y_k (Scalar)
      sum = 0.0d0
      do i1=1,n3
          sum = sum + Sk(i1) * Yk(i1)
      end do
      SkTYk = sum

      !HARUTA
     !! write(iw,*) 'SkTYk=',SkTYk
     !! if (SkTYk.NE.SkTYk) then
     !!     write(iw,'(a)') 'NaN Value detected. STOP.'
     !!     call abrt
     !! end if

      ! H_k * Y_k (Vector)
      do i1=1,n3
          sum = 0.0d0
          do i2=1,n3
              sum = sum + InvHess(i1,i2) * Yk(i2)
          end do
          HkYk(i1) = sum
      end do

      ! S_k * S_k^T (Matrix)
      do i1=1,n3
          do i2=1,n3
              SkSkT(i1,i2) = Sk(i1) * Sk(i2)
          end do
      end do

      ! (H_k * Y_k) * S_k^T (Matrix)
      do i1=1,n3
          do i2=1,n3
              HkYkSkT(i1,i2) = HkYk(i1) * Sk(i2)
          end do
      end do

      ! S_k * (H_k * Y_k)^T (Matrix)
      do i1=1,n3
          do i2=1,n3
              SkHkYkT(i1,i2) = Sk(i1) * HkYk(i2)
          end do
      end do

      ! Y_k^T * H_k * Y_k (Scalar)
      sum = 0.0d0
      do i1=1,n3
          sum = sum + Yk(i1) * HkYk(i1)
      end do
      YkTHkYk = sum

      ! Update Hessian Matrix
      do i1=1,n3
          do i2=1,n3
              InvHess(i1,i2) = InvHess(i1,i2) 
     &                   - ( HkYkSkT(i1,i2) + SkHkYkT(i1,i2) ) / SkTYk
     &                   + SkSkT(i1,i2) / SkTYk
     &                   + ( YkTHkYk / SkTYk**2 ) * SkSkT(i1,i2)
          end do
      end do
      
      if(maswrk.and.debug) then
       write(iw,'(a)') 'BFGS: Updated InvHess'
       do i1=1, n3
       write(iw,'(99f12.6)') (InvHess(i1,i),i=1,n3)
       end do
      endif

      end if !else
      
      ! Update atomic coordinates
      
      ! Determine the step size (alpha)
      ! Alpha should be determined by Armijo, Wolfe conditions. 
      ! This time we use heuristic method. ( a_k = 1/sqrt(k) )
      !alpha = 1/sqrt(dble(icycle-startcycle+1))
      alpha = 0.2d0

      do i1=1,n3 
       ! Determine the search direction (Newton direction = d_k)
       sum = 0.0d0 
       do i2=1,n3
        !sum = Newton direction (d_k)
        sum = sum + InvHess(i1,i2) * (-Fi(i2))
       end do
       ! Update Coordinate
       Xi(i1) = Xi(i1) - alpha * sum
      end do
      
      ! If did too large updating, do a modest updating
      disp=0.0d0
      do i=1, n3
       dif = dabs(Xi(i) - HisX(i,1))
       if (disp < dif) then
           disp = dif
       end if
      end do 
      
      if(maswrk.and.debug) then
       write(iw,'(a,f20.8)') 'BFGS: disp      : ',disp
      endif

      !displimit = 0.2d0
      if (displimit < disp) then
      if(maswrk.and.debug) then
       write(iw,'(a,f20.8)') 'BFGS: displimit : ',displimit
       write(iw,'(a)') 
     & 'BFGS: Too large updating detected. Scaling update step...'
       write(iw,'(a,f20.8)') 'BFGS: scale fac : ',displimit/disp
      endif
       do i=1, n3
        dif = Xi(i) - HisX(i,1)
        Xi(i) = HisX(i,1) + dif / disp * displimit 
       end do    

       ! Reset InvHess
      if(maswrk.and.debug) then
       write(iw,'(a)') 
     & 'BFGS: Reinitialized Inverted Hessian as Unit Matrix...' 
      endif
       do i1=1, n3
       do i2=1, n3
        InvHess(i1,i2) = 0.0d0
       end do
        InvHess(i1,i1) = 1.0d0
       end do

      end if
      
      end subroutine PATH_BFGS






!!!!!!!!!C*MODULE NEBPATH *DECK PATH_RMS
!!!!!!!!!C>
!!!!!!!!!C>    @brief    NEBPATH: Calculation RMS of vectors
!!!!!!!!!C>
!!!!!!!!!C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
!!!!!!!!!C>              Osaka Prefecture University, Japan
!!!!!!!!!C
!!!!!!!!!      function PATH_RMS(n, vec)
!!!!!!!!!      !------------------------------------------
!!!!!!!!!      !IMPLICIT DOUBLE PRECISION(A-H,O-Z)
!!!!!!!!!      implicit none
!!!!!!!!!      integer :: i
!!!!!!!!!      integer, intent(in) :: n
!!!!!!!!!      double precision, intent(in) :: vec(n)
!!!!!!!!!      double precision :: PATH_RMS
!!!!!!!!!c
!!!!!!!!!         if (size(vec) /= n) then
!!!!!!!!!            write(0,'(a)') 'PATH_RMS input error'
!!!!!!!!!         end if
!!!!!!!!!c
!!!!!!!!!         PATH_RMS = 0.0d0
!!!!!!!!!         do i = 1, n
!!!!!!!!!            PATH_RMS = PATH_RMS + vec(i)**2.0d0
!!!!!!!!!         end do
!!!!!!!!!         PATH_RMS = sqrt(PATH_RMS/dble(n))
!!!!!!!!!c
!!!!!!!!!      end function PATH_RMS 





C*MODULE NEBPATH *DECK NEB_euclid_norm
C>
C>    @brief    NEBPATH: Normalization of vectors
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      !------------------------------------------
      function NEB_euclid_norm(n, vec)
      ! NEB_euclid_norm calculates the euclid norm of vec.
      !------------------------------------------
      !IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      implicit none
      integer :: i
      integer, intent(in) :: n
      double precision, intent(in) :: vec(n)
      double precision :: NEB_euclid_norm
c
         if (size(vec) /= n) then
            write(0,'(a)') 'NEB_euclid_norm input error'
         end if
c
         NEB_euclid_norm = 0.0d0
         do i = 1, n
            NEB_euclid_norm = NEB_euclid_norm + vec(i)**2.0d0
         end do
         NEB_euclid_norm = sqrt(NEB_euclid_norm)
c
      end function NEB_euclid_norm




C*MODULE NEBPATH *DECK PATH_unit_vec2
C>
C>    @brief    NEBPATH: Getting a unit vector
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      !------------------------------------------
      subroutine PATH_unit_vec2(n,vec)
      ! unitvec calculates the unit vector of vec.
      !------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      dimension  vec(1:n)
c
c     r = NEB_euclid_norm(n,vec(1:n))
c     vec(1:n) = vec(1:n)/r
c
      r = 0.0d+00
      do i=1,n
         r = r +vec(i)**2
         enddo
      r = sqrt(r)
      do i=1,n
         vec(i) = vec(i)/r
         enddo
c
      end subroutine PATH_unit_vec2




C*MODULE NEBPATH *DECK PATH_read_restart
C>
C>    @brief    NEBPATH: Print out the restart data
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE PATH_read_restart(ir,iw,nat,zan,nimages,X,V,Grad,
     *              velo,maswrk,debug)
C
      !IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      implicit none
C
      integer, intent(in) :: ir, iw, NAT
      double precision, intent(in) :: ZAN(1:nat)
      integer, intent(in) :: nimages
      double precision, intent(out) :: X(1:3,1:nat,1:nimages)
      double precision, intent(out) :: V(1:nimages), Grad(1:nimages)
      double precision, intent(out) :: velo(1:3,1:nat,1:nimages)
      logical :: maswrk,debug
      integer :: i, j, iimage, jimage
      double precision :: zzan
      character(len=80) :: xline
      character(len=8), parameter :: keywrd = '$IMAGESX'
c     !                                        12345678
c
    1 format(a80)
c
      rewind ir
  100 continue
      read(ir,1,err=900,end=900) xline
      call PATH_capital(xline)
      if(xline(2:9).ne.keywrd) then
          go to 100
      end if
c
      do iimage=1,nimages
          read(ir,1,err=900,end=900) xline
          write(iw,'(a80)')xline
          read(xline(9:13),*) jimage
          if(jimage.ne.iimage) then
              if(maswrk) then
                  write(iw,9100) jimage,iimage
              end if
              call abrt
          endif
          read(xline(23:42),*) V(iimage)
          read(xline(54:73),*) Grad(iimage)
c
c         Coordinates...
          do i=1,nat
              read(ir,1,err=900,end=900) xline
              read(xline(11:80),*) zzan,(x(j,i,iimage),j=1,3)
              if(zzan.ne.zan(i)) then
                  if(maswrk) then
                      write(iw,9200) iimage,nat,zan(i),zzan
                  end if
                  call abrt
              endif
          enddo
c
c         Velocities...
          read(ir,1,err=900,end=900) xline
          do i=1,nat
              read(ir,1,err=900,end=900) xline
              read(xline(11:80),*) zzan,(velo(j,i,iimage),j=1,3)
              if(zzan.ne.zan(i)) then
                  if(maswrk) then
                      write(iw,9200) iimage,nat,zan(i),zzan
                  end if
                  call abrt
              endif
          enddo
      enddo
      return
 9100 format(/,'Error: jimage, iimage =',2i5)
 9200 format(/,'Error: iimage,nat,zan,zzan =',2i5,2f10.3)
c              1         2         3         4         5         6         7
c     123456789012345678901234567890123456789012345678901234567890123456789012345
c     #image =12345, Energy=12345678901234567890, Grad RMS =12345678901234567890
c     xxxxxxxxxx 1234567890,3f18.10)
c
  900 continue
      if(maswrk) then
          write(iw,9900) keywrd
      end if
      call abrt
 9900 format(/,'Error: reach the end of the input file...',
     *       /,'       could not file the keyword=',a8)
c
      end subroutine PATH_read_restart






C*MODULE NEBPATH *DECK PATH_trajectory
C>
C>    @brief    NEBPATH: Print out the coordinates and their velocities
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE PATH_trajectory(iw,nat,anam,bnam,zan,
     *              nimages,X,V,Grad,velo,icycle,maswrk,debug)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      double precision :: anam(1:nat),bnam(1:nat)
      double precision :: zan(1:nat)
      double precision :: X(1:3,1:nat,1:nimages)
      double precision :: V(1:nimages), Grad(1:nimages)
      double precision :: CV(1:3)
      double precision :: velo(1:3,1:nat,1:nimages)
      logical    maswrk,debug
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, two=2.0d+00)
c
      if(.not.maswrk) return
      write(iw,9000) icycle
      do iimage=1,nimages
         write(iw,9010) iimage,V(iimage),Grad(iimage)
c
c        Coordinates...
         do i=1,nat
            write(iw,9020) anam(i),bnam(i),zan(i),
     *           (x(j,i,iimage),j=1,3)
            enddo
c
c        Velocities...
         write(iw,9040)
         do i=1,nat
            write(iw,9022) anam(i),bnam(i),zan(i),
     *           (velo(j,i,iimage),j=1,3)
            enddo
         enddo
      write(iw,9900)
c
 9000 format(/,'*** Caution: all data are in atomic unit.',
     *       /,' $IMAGESX         icycle=',i8)
 9010 format('#image =',i5,', Energy=',f20.10,
     *', Grad RMS=',f20.12)
 9020 format(a8,a2,1x,f10.4,3f18.10)
 9022 format(a8,a2,1x,f10.4,3e18.8)
 9040 format('*** Velocities of atoms ---')
 9900 format(' $END')
c
c     a structure between the neighboring images...
      if(iw.eq.6) return
      write(iw,9100)
      izero = 0
      do iimage=1,(nimages-1)
         write(iw,9110) iimage,(iimage+1)
         write(iw,9010) izero,zero,zero
         do i=1,nat
            CV(1:3) = (X(1:3,i,iimage)+X(1:3,i,iimage+1))/two
            write(iw,9020) anam(i),bnam(i),zan(i),(CV(j),j=1,3)
            enddo
         enddo
 9110 format('*** This line must be deleted.  #iimage=',i3,' -',i3,
     *     /,'    And you have to renumber #image in your input.')
 9100 format('*** the followings are the coordinates between',
     *       ' the neighboring images.',
     *     /,'    You may like to add some of these into $IMAGESX',
     *       ' and change IMAGES.')
c
      end subroutine PATH_trajectory
      !--------------------------------------------------------------------------------------------------








C*MODULE NEBPATH *DECK PATH_finalresult
C>
C>    @brief    NEBPATH: Print out the coordinates and their velocities
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE PATH_finalresult(iw,nat,anam,bnam,zan,
     *              nimages,X,V,Grad,velo,icycle,maswrk,debug)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      double precision :: anam(1:nat),bnam(1:nat)
      double precision :: zan(1:nat)
      double precision :: X(1:3,1:nat,1:nimages)
      double precision :: V(1:nimages), Grad(1:nimages)
      double precision :: CV(1:3)
      double precision :: velo(1:3,1:nat,1:nimages)
      logical    maswrk,debug
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00, two=2.0d+00)
c
      if(.not.maswrk) return

      if(maswrk) then
          write(iw,'(100("-"))')
          write(iw,'(19x,a)')
     &'*** FINAL COORDINATES OF EACH IMAGES [atomic units] ***'
          write(iw,'(100("-"))')


          do iimage=1,nimages
              write(iw,9010) iimage,V(iimage),Grad(iimage)
c
c             Coordinates...
              do i=1,nat
                  write(iw,9020) anam(i),bnam(i),zan(i),
     *            (x(j,i,iimage),j=1,3)
              enddo
c
!c            Velocities...
!             write(iw,9040)
!             do i=1,nat
!                write(iw,9022) anam(i),bnam(i),zan(i),
!     *               (velo(j,i,iimage),j=1,3)
!             enddo
          enddo
          write(iw,'(100("-"))')
      end if

 9010 format('#image =',i5,', Energy=',f20.10,
     *', Grad RMS=',f20.12)
 9020 format(a8,a2,1x,f10.4,3f18.10)
 9022 format(a8,a2,1x,f10.4,3e18.8)
      end subroutine PATH_finalresult









C*MODULE NEBPATH *DECK PATH_RMS
C>
C>    @brief    NEBPATH: Calculation RMS of vectors
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      function PATH_RMS(n, vec)
      implicit none
      integer :: i
      integer, intent(in) :: n
      double precision, intent(in) :: vec(n)
      double precision :: PATH_RMS
      if (size(vec) /= n) then
         write(0,'(a)') 'PATH_RMS input error'
      end if
      PATH_RMS = 0.0d0
      do i = 1, n
         PATH_RMS = PATH_RMS + vec(i)**2.0d0
      end do
      PATH_RMS = sqrt(PATH_RMS/dble(n))
      end function PATH_RMS 







C*MODULE NEBPATH *DECK PATH_euclid_norm
C>
C>    @brief    NEBPATH: Calculates the euclid norm of vectors
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      function PATH_euclid_norm(n, vec)
      implicit none
      integer :: i
      integer, intent(in) :: n
      double precision, intent(in) :: vec(n)
      double precision :: PATH_euclid_norm
      if (size(vec) /= n) then
         write(0,'(a)') 'PATH_euclid_norm input error'
      end if
      PATH_euclid_norm = 0.0d0
      do i = 1, n
         PATH_euclid_norm = PATH_euclid_norm + vec(i)**2.0d0
      end do
      PATH_euclid_norm = sqrt(PATH_euclid_norm)
      end function PATH_euclid_norm






C*MODULE NEBPATH *DECK PATH_totlength
C>
C>    @brief    NEBPATH: Calculates total lentgh of string(X)
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_avelength(n3, nimages, X, avelength)
      implicit none
      integer, intent(in) :: n3, nimages
      double precision, intent(in) :: X(1:n3,1:nimages)
      double precision, intent(out) :: avelength
      integer :: iimages
      double precision :: PATH_euclid_norm
      double precision :: dist(1:n3)
!      function PATH_totlength(n, nimages, X)
!      implicit none
!      integer, intent(in) :: n, nimages
!      double precision, intent(in) :: X(:,:)
!      integer :: i, j, iimages
!      double precision :: PATH_totlength
!      double precision :: PATH_euclid_norm
!      double precision :: dr(1:n,1:nimages)
!      PATH_totlength = 0.0d0
!      do i = 1, n
!         dr(i,1:nimages) = X(i,1:nimages) 
!     &                   - cshift(X(i,1:nimages),shift=-1)
!         dr(i,1) = 0.0d0
!      end do
!      do iimages = 1, nimages
!         PATH_totlength = PATH_totlength 
!     &                  + PATH_euclid_norm(n, dr(1:n,iimages))
!      end do
!
      avelength = 0.0d0
      dist = 0.0d0
      do iimages = 1,nimages-1
          dist(1:n3) = X(1:n3,iimages+1) - X(1:n3,iimages)
          avelength = avelength 
     &                   + PATH_euclid_norm(n3, dist(1:n3))
      end do
      avelength = avelength / dble(nimages-1)
      end subroutine PATH_avelength







C*MODULE NEBPATH *DECK PATH_unit_vec
C>
C>    @brief    NEBPATH: Getting a unit vector
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine PATH_unit_vec(n,vec)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: n
      double precision, intent(inout) :: vec(1:n)
      integer :: i
      double precision :: r
!      dimension  vec(1:n)
c     r = PATH_euclid_norm(n,vec(1:n))
c     vec(1:n) = vec(1:n)/r
      r = 0.0d+00
      do i=1,n
         r = r +vec(i)**2
      enddo
      r = sqrt(r)
      do i=1,n
         vec(i) = vec(i)/r
      enddo
      end subroutine PATH_unit_vec






C*MODULE NEBPATH *DECK NEB_unit_vec
C>
C>    @brief    NEBPATH: Getting a unit vector
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      !------------------------------------------
      function NEB_unit_vec(n,vec)
      ! unitvec calculates the unit vector of vec.
      !------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer :: i
      integer, intent(in) :: n
      double precision, intent(in) :: vec(n)
      double precision :: NEB_unit_vec(1:n)
      double precision :: r
      double precision :: NEB_euclid_norm
c
         if (size(vec) /= n) then
            write(0,'(a)') 'Error of function unitvec'
         end if
         r = NEB_euclid_norm(n,vec)
         NEB_unit_vec(1:n) = vec(1:n)/r
      end function NEB_unit_vec





C*MODULE NEBPATH *DECK PATH_unit_vec_f
C>
C>    @brief    NEBPATH: Getting a unit vector
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
!      !------------------------------------------
!      function PATH_unit_vec_f(n,vec)
!      ! unitvec calculates the unit vector of vec.
!      !------------------------------------------
!      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
!      integer :: i
!      integer, intent(in) :: n
!      double precision, intent(in) :: vec(n)
!      double precision :: PATH_unit_vec_f(1:n)
!      double precision :: r
!      double precision :: PATH_euclid_norm
!c
!         if (size(vec) /= n) then
!            write(0,'(a)') 'Error of function unitvec'
!         end if
!         r = PATH_euclid_norm(n,vec)
!         PATH_unit_vec_f(1:n) = vec(1:n)/r
!      end function PATH_unit_vec_f
C --- ****************************************************





C*MODULE NEBPATH *DECK PATH_dot_prod
C>
C>    @brief    NEBPATH: calculates dot product of row vector and column
C>                       vector. Result is scalar
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      !------------------------------------------
      function PATH_dot_prod(n, vec1, vec2)
      !------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer :: i
      integer, intent(in) :: n
      double precision, intent(in) :: vec1(1:n), vec2(1:n)
      double precision :: PATH_dot_prod
c
         if (size(vec1) /= n .or. size(vec2) /= n) then
            write(0,'(a)') 'Error of function prod'
         end if
c
         PATH_dot_prod = 0.0d+00
         do i=1,n
            PATH_dot_prod = PATH_dot_prod + vec1(i)*vec2(i)
            end do
c
       end function PATH_dot_prod

